{
  "presentation": {
    "topics": [
      {
        "id": "title",
        "title": "Title Slide",
        "slides": [
          {
            "type": "title",
            "title": "Introduction to Rust Programming",
            "subtitle": "Safe, Fast, and Productive Systems Programming<br>From Beginner to Rustacean"
          }
        ]
      },
      {
        "id": "presenter",
        "title": "Presenter Slide",
        "slides": [
          {
            "type": "presenter",
            "name": "Aravind Govindhasamy",
            "title": "Software Developer",
            "experience": "3 years in .NET, Python, IoT & RFID",
            "oss_experience": "Full-Stack Development & UI Framework Specialist",
            "github": "https://github.com/aravind-govindhasamy",
            "website": "https://aravind-govindhasamy.github.io"
          }
        ]
      },
      {
        "id": "agenda",
        "title": "Agenda",
        "slides": [
          {
            "type": "content",
            "title": "What We'll Cover",
            "box": {
              "list": [
                {
                  "emoji": "üéØ",
                  "text": "<strong>What is Rust?</strong> - History & Philosophy"
                },
                {
                  "emoji": "‚ö°",
                  "text": "<strong>Why Rust?</strong> - Speed + Safety + Concurrency"
                },
                {
                  "emoji": "üõ†Ô∏è",
                  "text": "<strong>Installation & Tooling</strong> - rustup, Cargo, rustfmt"
                },
                {
                  "emoji": "üìö",
                  "text": "<strong>Basic Syntax</strong> - Variables, Functions, Control Flow"
                },
                {
                  "emoji": "üèõÔ∏è",
                  "text": "<strong>Ownership System</strong> - Core Rust Concept"
                },
                {
                  "emoji": "üìù",
                  "text": "<strong>Borrowing & Lifetimes</strong> - Memory Safety"
                },
                {
                  "emoji": "üé≠",
                  "text": "<strong>Enums & Pattern Matching</strong> - Expressive Types"
                },
                {
                  "emoji": "‚ö°",
                  "text": "<strong>Error Handling</strong> - Result & Option Types"
                },
                {
                  "emoji": "üèóÔ∏è",
                  "text": "<strong>Structs & Traits</strong> - Data Structures & Polymorphism"
                },
                {
                  "emoji": "üì¶",
                  "text": "<strong>Generics & Collections</strong> - Reusable Code"
                },
                {
                  "emoji": "üîÑ",
                  "text": "<strong>Concurrency</strong> - Fearless Parallel Programming"
                },
                {
                  "emoji": "üåê",
                  "text": "<strong>Async Rust</strong> - Async/Await & Tokio"
                },
                {
                  "emoji": "üî¨",
                  "text": "<strong>Testing & Documentation</strong> - Built-in Tools"
                },
                {
                  "emoji": "üöÄ",
                  "text": "<strong>Real-world Applications</strong> - Web, Embedded, WASM"
                },
                {
                  "emoji": "üíº",
                  "text": "<strong>Career & Learning Path</strong> - Next Steps"
                }
              ]
            }
          }
        ]
      },
      {
        "id": "what-is-rust",
        "title": "What is Rust?",
        "slides": [
          {
            "type": "topic-title",
            "title": "Understanding Rust"
          },
          {
            "type": "content",
            "emoji": "üéØ",
            "title": "What is Rust?",
            "box": {
              "content": "<span class=\"highlight\">Systems programming language</span> focused on safety, speed, and concurrency",
              "list": [
                {
                  "emoji": "‚ö°",
                  "text": "<strong>Created by</strong> - Graydon Hoare (Mozilla, 2010)"
                },
                {
                  "emoji": "üîí",
                  "text": "<strong>Memory Safety</strong> - No garbage collector, no segfaults"
                },
                {
                  "emoji": "üöÄ",
                  "text": "<strong>Performance</strong> - C/C++ level speed"
                },
                {
                  "emoji": "üîÑ",
                  "text": "<strong>Concurrency</strong> - Fearless parallel programming"
                },
                {
                  "emoji": "üèÜ",
                  "text": "<strong>Adoption</strong> - Most loved language 8+ years running"
                }
              ]
            },
            "note": {
              "text": "<strong>Fun fact:</strong> Rust's compiler is so good at catching bugs that most Rust programs that compile correctly run correctly!"
            }
          }
        ]
      },
      {
        "id": "history",
        "title": "History & Evolution",
        "slides": [
          {
            "type": "topic-title",
            "title": "Rust History"
          },
          {
            "type": "content",
            "emoji": "üìú",
            "title": "Key Milestones",
            "box": {
              "list": [
                {
                  "emoji": "1Ô∏è‚É£",
                  "text": "<strong>2006</strong> - Graydon Hoare starts Rust as personal project"
                },
                {
                  "emoji": "2Ô∏è‚É£",
                  "text": "<strong>2009</strong> - Mozilla sponsors development"
                },
                {
                  "emoji": "3Ô∏è‚É£",
                  "text": "<strong>2010</strong> - First public announcement"
                },
                {
                  "emoji": "4Ô∏è‚É£",
                  "text": "<strong>2015</strong> - Rust 1.0 released"
                },
                {
                  "emoji": "5Ô∏è‚É£",
                  "text": "<strong>2016-2021</strong> - Rapid adoption in industry"
                },
                {
                  "emoji": "6Ô∏è‚É£",
                  "text": "<strong>2021</strong> - Rust Foundation established"
                }
              ]
            }
          }
        ]
      },
      {
        "id": "why-rust",
        "title": "Why Choose Rust?",
        "slides": [
          {
            "type": "topic-title",
            "title": "The Rust Advantage"
          },
          {
            "type": "content",
            "emoji": "‚ö°",
            "title": "Performance + Safety",
            "box": {
              "list": [
                {
                  "emoji": "üöÄ",
                  "text": "<strong>C/C++ Performance</strong> - Zero-cost abstractions"
                },
                {
                  "emoji": "üîí",
                  "text": "<strong>Memory Safety</strong> - No null pointers, no data races"
                },
                {
                  "emoji": "üìö",
                  "text": "<strong>Productivity</strong> - Modern tooling and package management"
                },
                {
                  "emoji": "üîÑ",
                  "text": "<strong>Concurrency</strong> - Compiler prevents data races"
                },
                {
                  "emoji": "üåê",
                  "text": "<strong>Portability</strong> - Runs everywhere from embedded to web"
                }
              ]
            }
          },
          {
            "type": "content",
            "emoji": "üèÜ",
            "title": "Industry Adoption",
            "box": {
              "list": [
                {
                  "emoji": "ü™ü",
                  "text": "<strong>Microsoft</strong> - Rewriting Windows components in Rust"
                },
                {
                  "emoji": "üêß",
                  "text": "<strong>Linux Kernel</strong> - Official support for Rust drivers"
                },
                {
                  "emoji": "üåê",
                  "text": "<strong>Google</strong> - Android OS and Fuchsia"
                },
                {
                  "emoji": "üçé",
                  "text": "<strong>Apple</strong> - Core system components"
                },
                {
                  "emoji": "üì¶",
                  "text": "<strong>Amazon</strong> - Firecracker microVM"
                },
                {
                  "emoji": "üîó",
                  "text": "<strong>Meta</strong> - Source control backend"
                }
              ]
            }
          }
        ]
      },
      {
        "id": "installation",
        "title": "Installation & Setup",
        "slides": [
          {
            "type": "topic-title",
            "title": "Getting Started with Rust"
          },
          {
            "type": "content",
            "emoji": "üõ†Ô∏è",
            "title": "Installing Rust",
            "box": {
              "content": "<strong>Using rustup (recommended)</strong>",
              "code": "# Install rustup\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n\n# Or on Windows, download from:\n# https://rustup.rs/\n\n# Verify installation\nrustc --version\ncargo --version\n\n# Update Rust\nrustup update\n\n# Install documentation locally\nrustup doc"
            }
          },
          {
            "type": "content",
            "emoji": "üì¶",
            "title": "Essential Tools",
            "box": {
              "list": [
                {
                  "emoji": "üõ†Ô∏è",
                  "text": "<strong>rustc</strong> - Rust compiler"
                },
                {
                  "emoji": "üì¶",
                  "text": "<strong>Cargo</strong> - Package manager and build system"
                },
                {
                  "emoji": "üìù",
                  "text": "<strong>rustfmt</strong> - Code formatter"
                },
                {
                  "emoji": "üîç",
                  "text": "<strong>Clippy</strong> - Linter for catching common mistakes"
                },
                {
                  "emoji": "üìö",
                  "text": "<strong>rustdoc</strong> - Documentation generator"
                }
              ]
            }
          }
        ]
      },
      {
        "id": "cargo",
        "title": "Cargo Package Manager",
        "slides": [
          {
            "type": "topic-title",
            "title": "Cargo: Rust's Build System"
          },
          {
            "type": "content",
            "emoji": "üì¶",
            "title": "Cargo Basics",
            "box": {
              "content": "<strong>Common Cargo commands</strong>",
              "code": "# Create new project\ncargo new my_project\ncargo new --lib my_library\n\n# Build project\ncargo build\ncargo build --release  # Optimized build\n\n# Run project\ncargo run\n\n# Check code without building\ncargo check\n\n# Run tests\ncargo test\n\n# Generate documentation\ncargo doc --open\n\n# Add dependency\ncargo add serde\n\n# Update dependencies\ncargo update"
            }
          },
          {
            "type": "content",
            "emoji": "üìÅ",
            "title": "Project Structure",
            "box": {
              "content": "<strong>Typical Rust project layout</strong>",
              "code": "my_project/\n‚îú‚îÄ‚îÄ Cargo.toml          # Project manifest\n‚îú‚îÄ‚îÄ Cargo.lock          # Dependency versions\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ main.rs         # Binary crate root\n‚îÇ   ‚îú‚îÄ‚îÄ lib.rs          # Library crate root\n‚îÇ   ‚îî‚îÄ‚îÄ bin/            # Additional binaries\n‚îú‚îÄ‚îÄ tests/              # Integration tests\n‚îú‚îÄ‚îÄ examples/           # Example code\n‚îî‚îÄ‚îÄ target/             # Build output (generated)\n\n# Cargo.toml example\n[package]\nname = \"my_project\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nserde = \"1.0\"\nreqwest = { version = \"0.11\", features = [\"json\"] }"
            }
          }
        ]
      },
      {
        "id": "basic-syntax",
        "title": "Basic Syntax",
        "slides": [
          {
            "type": "topic-title",
            "title": "Rust Fundamentals"
          },
          {
            "type": "content",
            "emoji": "üìù",
            "title": "Variables & Mutability",
            "box": {
              "content": "<strong>Variable declarations</strong>",
              "code": "fn main() {\n    // Immutable by default\n    let x = 5;\n    // x = 6;  // Error: cannot assign twice to immutable variable\n    \n    // Mutable variable\n    let mut y = 5;\n    y = 6;  // OK\n    \n    // Constants\n    const MAX_POINTS: u32 = 100_000;\n    \n    // Shadowing\n    let spaces = \"   \";\n    let spaces = spaces.len();  // Different type, same name\n    \n    // Type annotations\n    let guess: u32 = \"42\".parse().expect(\"Not a number!\");\n}"
            }
          },
          {
            "type": "content",
            "emoji": "üéØ",
            "title": "Data Types",
            "box": {
              "content": "<strong>Scalar and compound types</strong>",
              "code": "// Scalar types\nlet x: i32 = -42;        // Signed integer\nlet y: u64 = 42;         // Unsigned integer\nlet z: f64 = 3.14;       // Floating point\nlet is_rust_cool: bool = true;\nlet c: char = 'ü¶Ä';      // Unicode scalar value\n\n// Compound types\nlet tup: (i32, f64, u8) = (500, 6.4, 1);\nlet (x, y, z) = tup;     // Destructuring\nlet five_hundred = tup.0;\n\nlet arr = [1, 2, 3, 4, 5];\nlet first = arr[0];\nlet months = [\"Jan\", \"Feb\", \"Mar\"];  // Fixed size\n\n// String types\nlet s1 = \"hello\";        // String slice (&str)\nlet s2 = String::from(\"hello\");  // String (growable, heap-allocated)"
            }
          }
        ]
      },
      {
        "id": "functions",
        "title": "Functions & Control Flow",
        "slides": [
          {
            "type": "topic-title",
            "title": "Functions and Control Structures"
          },
          {
            "type": "content",
            "emoji": "üìù",
            "title": "Functions",
            "box": {
              "content": "<strong>Function definitions and expressions</strong>",
              "code": "// Function with parameters and return type\nfn add(x: i32, y: i32) -> i32 {\n    x + y  // No semicolon = return value\n}\n\n// Function with explicit return\nfn subtract(x: i32, y: i32) -> i32 {\n    return x - y;\n}\n\n// Statements vs Expressions\nfn expressions() {\n    let y = {\n        let x = 3;\n        x + 1  // This is an expression\n    };  // y = 4\n    \n    println!(\"The value of y is: {y}\");\n}\n\n// Main function\nfn main() {\n    let result = add(5, 3);\n    println!(\"5 + 3 = {result}\");\n}"
            }
          },
          {
            "type": "content",
            "emoji": "üîÑ",
            "title": "Control Flow",
            "box": {
              "content": "<strong>if, loop, while, for</strong>",
              "code": "// If expressions\nlet number = 6;\nif number % 4 == 0 {\n    println!(\"number is divisible by 4\");\n} else if number % 3 == 0 {\n    println!(\"number is divisible by 3\");\n} else {\n    println!(\"number is not divisible by 4 or 3\");\n}\n\n// Using if in let statement\nlet condition = true;\nlet number = if condition { 5 } else { 6 };\n\n// Loops\nloop {\n    println!(\"again!\");  // Infinite loop\n    break;               // Break out\n}\n\n// Returning from loops\nlet mut counter = 0;\nlet result = loop {\n    counter += 1;\n    if counter == 10 {\n        break counter * 2;\n    }\n};\n\n// While loop\nwhile counter != 0 {\n    println!(\"{counter}!\");\n    counter -= 1;\n}\n\n// For loop (most common)\nlet arr = [10, 20, 30, 40, 50];\nfor element in arr {\n    println!(\"the value is: {element}\");\n}\n\n// Range with for\nfor number in (1..4).rev() {\n    println!(\"{number}!\");\n}"
            }
          }
        ]
      },
      {
        "id": "ownership",
        "title": "Ownership System",
        "slides": [
          {
            "type": "topic-title",
            "title": "Rust's Core Concept: Ownership"
          },
          {
            "type": "content",
            "emoji": "üèõÔ∏è",
            "title": "Ownership Rules",
            "box": {
              "content": "<strong>The three rules of ownership</strong>",
              "code": "// Rule 1: Each value has an owner\nlet s1 = String::from(\"hello\");  // s1 owns the string\n\n// Rule 2: Only one owner at a time\nlet s2 = s1;  // s1 is no longer valid (move semantics)\n// println!(\"{s1}\");  // Error: borrow of moved value\n\n// Rule 3: When owner goes out of scope, value is dropped\n{\n    let s3 = String::from(\"hello\");\n    // s3 is valid here\n} // s3 goes out of scope, memory is freed\n\n// Clone for deep copy\nlet s1 = String::from(\"hello\");\nlet s2 = s1.clone();  // Both s1 and s2 are valid\nprintln!(\"s1 = {}, s2 = {}\", s1, s2);\n\n// Copy trait for simple types\nlet x = 5;\nlet y = x;  // Copy, not move\nprintln!(\"x = {}, y = {}\", x, y);  // Both valid"
            }
          },
          {
            "type": "content",
            "emoji": "üìö",
            "title": "Ownership and Functions",
            "box": {
              "content": "<strong>How ownership works with functions</strong>",
              "code": "fn main() {\n    let s = String::from(\"hello\");  // s comes into scope\n    \n    takes_ownership(s);             // s's value moves into the function\n                                    // s is no longer valid here\n    \n    let x = 5;                      // x comes into scope\n    \n    makes_copy(x);                  // x would move into the function,\n                                    // but i32 is Copy, so it's okay to still\n                                    // use x afterward\n    println!(\"x is still: {x}\");    // This works\n    \n} // Here, x goes out of scope, then s. But because s's value was moved, nothing\n  // special happens.\n\nfn takes_ownership(some_string: String) { // some_string comes into scope\n    println!(\"{some_string}\");\n} // Here, some_string goes out of scope and `drop` is called. The backing\n  // memory is freed.\n\nfn makes_copy(some_integer: i32) { // some_integer comes into scope\n    println!(\"{some_integer}\");\n} // Here, some_integer goes out of scope. Nothing special happens."
            }
          }
        ]
      },
      {
        "id": "borrowing",
        "title": "Borrowing & References",
        "slides": [
          {
            "type": "topic-title",
            "title": "References and Borrowing"
          },
          {
            "type": "content",
            "emoji": "üìù",
            "title": "References",
            "box": {
              "content": "<strong>Borrowing with references</strong>",
              "code": "fn main() {\n    let s1 = String::from(\"hello\");\n    \n    // Reference without taking ownership\n    let len = calculate_length(&s1);\n    \n    println!(\"The length of '{}' is {}.\", s1, len);\n    \n    // Mutable references\n    let mut s = String::from(\"hello\");\n    change(&mut s);\n    println!(\"Changed string: {s}\");\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n} // s goes out of scope, but because it doesn't have ownership,\n  // nothing happens\n\nfn change(some_string: &mut String) {\n    some_string.push_str(\", world\");\n}\n\n// Rules of References:\n// 1. At any time, you can have either one mutable reference or\n//    any number of immutable references.\n// 2. References must always be valid."
            }
          },
          {
            "type": "content",
            "emoji": "üö´",
            "title": "Reference Rules",
            "box": {
              "content": "<strong>Preventing data races at compile time</strong>",
              "code": "let mut s = String::from(\"hello\");\n\n// Multiple immutable references - OK\nlet r1 = &s;\nlet r2 = &s;\nprintln!(\"{r1} and {r2}\");\n\n// One mutable reference - OK\nlet r3 = &mut s;\nr3.push_str(\", world\");\n\n// This would cause errors:\n// let r1 = &s;     // Immutable borrow\n// let r2 = &mut s; // Mutable borrow - ERROR!\n// println!(\"{r1}\");\n\n// This is also an error:\n// let mut r1 = &mut s;\n// let mut r2 = &mut s; // Second mutable borrow - ERROR!\n// r1.push_str(\", hello\");\n// r2.push_str(\", world\");\n\n// Dangling references prevented by compiler\n// fn dangle() -> &String {  // ERROR: missing lifetime specifier\n//     let s = String::from(\"hello\");\n//     &s  // s goes out of scope, memory is freed\n// } // Dangerous reference returned!"
            }
          }
        ]
      },
      {
        "id": "slices",
        "title": "Slices",
        "slides": [
          {
            "type": "topic-title",
            "title": "Slice Type"
          },
          {
            "type": "content",
            "emoji": "üî™",
            "title": "String and Array Slices",
            "box": {
              "content": "<strong>References to contiguous sequences</strong>",
              "code": "fn main() {\n    // String slices\n    let s = String::from(\"hello world\");\n    \n    let hello = &s[0..5];\n    let world = &s[6..11];\n    \n    println!(\"{hello} {world}\");\n    \n    // Array slices\n    let a = [1, 2, 3, 4, 5];\n    let slice = &a[1..3];  // [2, 3]\n    \n    assert_eq!(slice, &[2, 3]);\n}\n\n// Using slices in function signatures\nfn first_word(s: &str) -> &str {\n    let bytes = s.as_bytes();\n    \n    for (i, &item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return &s[0..i];\n        }\n    }\n    \n    &s[..]\n}\n\nfn main() {\n    let my_string = String::from(\"hello world\");\n    \n    // first_word works on slices of String\n    let word = first_word(&my_string[..]);\n    println!(\"First word: {word}\");\n    \n    // Also works on string literals (which are slices)\n    let my_string_literal = \"hello world\";\n    let word = first_word(&my_string_literal[..]);\n    let word = first_word(my_string_literal);  // Even better\n}"
            }
          }
        ]
      },
      {
        "id": "structs",
        "title": "Structs",
        "slides": [
          {
            "type": "topic-title",
            "title": "Structures"
          },
          {
            "type": "content",
            "emoji": "üèóÔ∏è",
            "title": "Defining and Using Structs",
            "box": {
              "content": "<strong>Custom data types with struct</strong>",
              "code": "// Define a struct\nstruct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n\nfn main() {\n    // Create an instance\n    let user1 = User {\n        email: String::from(\"someone@example.com\"),\n        username: String::from(\"someusername123\"),\n        active: true,\n        sign_in_count: 1,\n    };\n    \n    // Access fields\n    println!(\"User email: {}\", user1.email);\n    \n    // Mutable instance\n    let mut user2 = User {\n        email: String::from(\"someone2@example.com\"),\n        username: String::from(\"someusername456\"),\n        active: true,\n        sign_in_count: 1,\n    };\n    \n    user2.email = String::from(\"anotheremail@example.com\");\n    \n    // Struct update syntax\n    let user3 = User {\n        email: String::from(\"user3@example.com\"),\n        ..user1  // username is moved from user1!\n    };\n}\n\n// Tuple structs\nstruct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\n\nfn main() {\n    let black = Color(0, 0, 0);\n    let origin = Point(0, 0, 0);\n}"
            }
          },
          {
            "type": "content",
            "emoji": "üìù",
            "title": "Struct Methods",
            "box": {
              "content": "<strong>Implementing methods with impl</strong>",
              "code": "struct Rectangle {\n    width: u32,\n    height: u32,\n}\n\n// Implementation block\nimpl Rectangle {\n    // Method - takes &self\n    fn area(&self) -> u32 {\n        self.width * self.height\n    }\n    \n    // Method with parameters\n    fn can_hold(&self, other: &Rectangle) -> bool {\n        self.width > other.width && self.height > other.height\n    }\n    \n    // Associated function (no self) - called with ::\n    fn square(size: u32) -> Self {\n        Self {\n            width: size,\n            height: size,\n        }\n    }\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n    \n    let rect2 = Rectangle {\n        width: 10,\n        height: 40,\n    };\n    \n    println!(\"Area: {}\", rect1.area());\n    println!(\"Can rect1 hold rect2? {}\", rect1.can_hold(&rect2));\n    \n    // Call associated function\n    let sq = Rectangle::square(3);\n}"
            }
          }
        ]
      },
      {
        "id": "enums-pattern-matching",
        "title": "Enums & Pattern Matching",
        "slides": [
          {
            "type": "topic-title",
            "title": "Enumerations and Pattern Matching"
          },
          {
            "type": "content",
            "emoji": "üé≠",
            "title": "Enums",
            "box": {
              "content": "<strong>Defining and using enums</strong>",
              "code": "// Basic enum\nenum IpAddrKind {\n    V4,\n    V6,\n}\n\n// Enum with data\nenum IpAddr {\n    V4(u8, u8, u8, u8),\n    V6(String),\n}\n\n// Complex enum\nenum Message {\n    Quit,                           // No data\n    Move { x: i32, y: i32 },       // Anonymous struct\n    Write(String),                  // Single String\n    ChangeColor(i32, i32, i32),    // Three i32 values\n}\n\n// Methods on enums\nimpl Message {\n    fn call(&self) {\n        // method body would be defined here\n    }\n}\n\nfn main() {\n    let four = IpAddrKind::V4;\n    let six = IpAddrKind::V6;\n    \n    let home = IpAddr::V4(127, 0, 0, 1);\n    let loopback = IpAddr::V6(String::from(\"::1\"));\n    \n    let m = Message::Write(String::from(\"hello\"));\n    m.call();\n}\n\n// The Option enum (built-in)\n// enum Option<T> {\n//     None,\n//     Some(T),\n// }"
            }
          },
          {
            "type": "content",
            "emoji": "üîç",
            "title": "Pattern Matching with match",
            "box": {
              "content": "<strong>Exhaustive pattern matching</strong>",
              "code": "enum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter,\n}\n\nfn value_in_cents(coin: Coin) -> u8 {\n    match coin {\n        Coin::Penny => {\n            println!(\"Lucky penny!\");\n            1\n        }\n        Coin::Nickel => 5,\n        Coin::Dime => 10,\n        Coin::Quarter => 25,\n    }\n}\n\n// Matching with Option<T>\nfn plus_one(x: Option<i32>) -> Option<i32> {\n    match x {\n        None => None,\n        Some(i) => Some(i + 1),\n    }\n}\n\nfn main() {\n    let five = Some(5);\n    let six = plus_one(five);\n    let none = plus_one(None);\n    \n    // Catch-all patterns\n    let dice_roll = 9;\n    match dice_roll {\n        3 => add_fancy_hat(),\n        7 => remove_fancy_hat(),\n        other => move_player(other),  // Catch-all with value\n        // _ => (),  // Catch-all without value\n    }\n    \n    // if let syntax (sugar for match with one pattern)\n    let config_max = Some(3u8);\n    if let Some(max) = config_max {\n        println!(\"The maximum is configured to be {max}\");\n    }\n}\n\nfn add_fancy_hat() {}\nfn remove_fancy_hat() {}\nfn move_player(_spaces: u8) {}"
            }
          }
        ]
      },
      {
        "id": "error-handling",
        "title": "Error Handling",
        "slides": [
          {
            "type": "topic-title",
            "title": "Robust Error Handling"
          },
          {
            "type": "content",
            "emoji": "‚ö°",
            "title": "Result Type",
            "box": {
              "content": "<strong>Recoverable errors with Result</strong>",
              "code": "use std::fs::File;\nuse std::io::ErrorKind;\n\n// Result enum definition:\n// enum Result<T, E> {\n//     Ok(T),\n//     Err(E),\n// }\n\nfn main() {\n    // Handling Result with match\n    let greeting_file_result = File::open(\"hello.txt\");\n    \n    let greeting_file = match greeting_file_result {\n        Ok(file) => file,\n        Err(error) => match error.kind() {\n            ErrorKind::NotFound => match File::create(\"hello.txt\") {\n                Ok(fc) => fc,\n                Err(e) => panic!(\"Problem creating the file: {:?}\", e),\n            },\n            other_error => {\n                panic!(\"Problem opening the file: {:?}\", other_error);\n            }\n        },\n    };\n    \n    // Using unwrap and expect\n    let file1 = File::open(\"hello.txt\").unwrap();  // Panics on error\n    let file2 = File::open(\"hello.txt\").expect(\"Failed to open hello.txt\");\n    \n    // Propagating errors with ?\n    let content = read_username_from_file().expect(\"Failed to read username\");\n    println!(\"Username: {content}\");\n}\n\n// Propagating errors\nfn read_username_from_file() -> Result<String, std::io::Error> {\n    let mut username = String::new();\n    \n    // The ? operator automatically propagates errors\n    std::fs::File::open(\"hello.txt\")?\n        .read_to_string(&mut username)?;\n    \n    Ok(username)\n}\n\n// Even simpler with fs::read_to_string\nfn read_username_simple() -> Result<String, std::io::Error> {\n    std::fs::read_to_string(\"hello.txt\")\n}"
            }
          },
          {
            "type": "content",
            "emoji": "üö®",
            "title": "Unrecoverable Errors",
            "box": {
              "content": "<strong>panic! for unrecoverable errors</strong>",
              "code": "fn main() {\n    // panic! macro stops execution\n    // panic!(\"crash and burn\");\n    \n    let v = vec![1, 2, 3];\n    \n    // This will panic at runtime\n    // v[99];  // index out of bounds\n    \n    // Better error handling\n    let item = v.get(99);\n    match item {\n        Some(value) => println!(\"Item: {value}\"),\n        None => println!(\"Index out of bounds\"),\n    }\n}\n\n// Custom validation with Result\nfn create_user(username: &str) -> Result<User, String> {\n    if username.len() < 3 {\n        return Err(\"Username must be at least 3 characters\".to_string());\n    }\n    if username.len() > 20 {\n        return Err(\"Username must be at most 20 characters\".to_string());\n    }\n    \n    Ok(User {\n        username: username.to_string(),\n        email: String::new(),\n        active: true,\n        sign_in_count: 0,\n    })\n}"
            }
          }
        ]
      },
      {
        "id": "generics-traits",
        "title": "Generics & Traits",
        "slides": [
          {
            "type": "topic-title",
            "title": "Generic Types and Traits"
          },
          {
            "type": "content",
            "emoji": "üì¶",
            "title": "Generic Functions and Structs",
            "box": {
              "content": "<strong>Writing generic code</strong>",
              "code": "// Generic function\nfn largest<T: PartialOrd>(list: &[T]) -> &T {\n    let mut largest = &list[0];\n    \n    for item in list {\n        if item > largest {\n            largest = item;\n        }\n    }\n    \n    largest\n}\n\n// Generic struct\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\n// Generic methods\nimpl<T> Point<T> {\n    fn x(&self) -> &T {\n        &self.x\n    }\n}\n\n// Concrete implementation for f32\nimpl Point<f32> {\n    fn distance_from_origin(&self) -> f32 {\n        (self.x.powi(2) + self.y.powi(2)).sqrt()\n    }\n}\n\n// Multiple generic types\nstruct Point2<T, U> {\n    x: T,\n    y: U,\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n    let result = largest(&number_list);\n    println!(\"The largest number is {result}\");\n    \n    let char_list = vec!['y', 'm', 'a', 'q'];\n    let result = largest(&char_list);\n    println!(\"The largest char is {result}\");\n    \n    let integer_point = Point { x: 5, y: 10 };\n    let float_point = Point { x: 1.0, y: 4.0 };\n    let distance = float_point.distance_from_origin();\n}"
            }
          },
          {
            "type": "content",
            "emoji": "üéØ",
            "title": "Traits",
            "box": {
              "content": "<strong>Defining shared behavior</strong>",
              "code": "// Trait definition\npub trait Summary {\n    fn summarize(&self) -> String;\n    \n    // Default implementation\n    fn summarize_author(&self) -> String {\n        String::from(\"(Unknown author)\")\n    }\n}\n\n// Types implementing the trait\npub struct NewsArticle {\n    pub headline: String,\n    pub location: String,\n    pub author: String,\n    pub content: String,\n}\n\nimpl Summary for NewsArticle {\n    fn summarize(&self) -> String {\n        format!(\"{}, by {} ({})\", self.headline, self.author, self.location)\n    }\n    \n    fn summarize_author(&self) -> String {\n        self.author.clone()\n    }\n}\n\npub struct Tweet {\n    pub username: String,\n    pub content: String,\n    pub reply: bool,\n    pub retweet: bool,\n}\n\nimpl Summary for Tweet {\n    fn summarize(&self) -> String {\n        format!(\"{}: {}\", self.username, self.content)\n    }\n}\n\n// Trait bounds in functions\npub fn notify<T: Summary>(item: &T) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n\n// Multiple trait bounds\npub fn notify_multiple<T: Summary + Display>(item: &T) {}\n\n// where clause for complex bounds\nfn some_function<T, U>(t: &T, u: &U) -> i32\nwhere\n    T: Display + Clone,\n    U: Clone + Debug,\n{\n    // function body\n}\n\n// Returning types that implement traits\nfn returns_summarizable() -> impl Summary {\n    Tweet {\n        username: String::from(\"horse_ebooks\"),\n        content: String::from(\"of course, as you probably already know, people\"),\n        reply: false,\n        retweet: false,\n    }\n}"
            }
          }
        ]
      },
      {
        "id": "lifetimes",
        "title": "Lifetimes",
        "slides": [
          {
            "type": "topic-title",
            "title": "Lifetime Annotations"
          },
          {
            "type": "content",
            "emoji": "‚è≥",
            "title": "Understanding Lifetimes",
            "box": {
              "content": "<strong>Preventing dangling references</strong>",
              "code": "// Lifetime annotations in function signatures\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n\nfn main() {\n    let string1 = String::from(\"abcd\");\n    let string2 = \"xyz\";\n    \n    let result = longest(string1.as_str(), string2);\n    println!(\"The longest string is {result}\");\n    \n    // This works because both references live long enough\n    let string3 = String::from(\"long string is long\");\n    {\n        let string4 = String::from(\"xyz\");\n        let result2 = longest(string3.as_str(), string4.as_str());\n        println!(\"The longest string is {result2}\");\n    }\n    \n    // This would cause an error:\n    // let string5 = String::from(\"long string is long\");\n    // let result3;\n    // {\n    //     let string6 = String::from(\"xyz\");\n    //     result3 = longest(string5.as_str(), string6.as_str());\n    // }\n    // println!(\"The longest string is {result3}\");  // ERROR!\n}\n\n// Lifetime annotations in structs\nstruct ImportantExcerpt<'a> {\n    part: &'a str,\n}\n\nfn main() {\n    let novel = String::from(\"Call me Ishmael. Some years ago...\");\n    let first_sentence = novel.split('.').next().expect(\"Could not find a '.'\");\n    let i = ImportantExcerpt {\n        part: first_sentence,\n    };\n    println!(\"Excerpt: {}\", i.part);\n}\n\n// Lifetime elision rules\nfn first_word(s: &str) -> &str {  // Compiler adds lifetimes automatically\n    let bytes = s.as_bytes();\n    for (i, &item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return &s[0..i];\n        }\n    }\n    &s[..]\n}\n\n// Static lifetime\nlet s: &'static str = \"I have a static lifetime.\";"
            }
          }
        ]
      },
      {
        "id": "collections",
        "title": "Collections",
        "slides": [
          {
            "type": "topic-title",
            "title": "Common Collections"
          },
          {
            "type": "content",
            "emoji": "üìö",
            "title": "Vector, String, HashMap",
            "box": {
              "content": "<strong>Standard library collections</strong>",
              "code": "use std::collections::HashMap;\n\nfn main() {\n    // Vectors\n    let mut v: Vec<i32> = Vec::new();\n    v.push(1);\n    v.push(2);\n    v.push(3);\n    \n    // Macro for creating vectors\n    let v2 = vec![1, 2, 3];\n    \n    // Accessing elements\n    let third: &i32 = &v2[2];  // Panics if out of bounds\n    println!(\"The third element is {third}\");\n    \n    match v2.get(2) {  // Returns Option\n        Some(third) => println!(\"The third element is {third}\"),\n        None => println!(\"There is no third element.\"),\n    }\n    \n    // Iterating\n    for i in &v2 {\n        println!(\"{i}\");\n    }\n    \n    // Strings\n    let mut s = String::new();\n    s.push_str(\"hello\");\n    s.push('!');\n    \n    let s1 = String::from(\"Hello, \");\n    let s2 = String::from(\"world!\");\n    let s3 = s1 + &s2;  // s1 is moved here\n    \n    // Format macro (doesn't take ownership)\n    let s4 = format!(\"{s3}-{s2}\");\n    \n    // Hash Maps\n    let mut scores = HashMap::new();\n    scores.insert(String::from(\"Blue\"), 10);\n    scores.insert(String::from(\"Yellow\"), 50);\n    \n    // Accessing values\n    let team_name = String::from(\"Blue\");\n    let score = scores.get(&team_name).copied().unwrap_or(0);\n    \n    // Iterating\n    for (key, value) in &scores {\n        println!(\"{key}: {value}\");\n    }\n    \n    // Updating\n    scores.insert(String::from(\"Blue\"), 25);  // Overwrite\n    scores.entry(String::from(\"Yellow\")).or_insert(50);  // Insert if not exists\n}"
            }
          }
        ]
      },
      {
        "id": "testing",
        "title": "Testing",
        "slides": [
          {
            "type": "topic-title",
            "title": "Testing in Rust"
          },
          {
            "type": "content",
            "emoji": "üß™",
            "title": "Writing Tests",
            "box": {
              "content": "<strong>Built-in testing framework</strong>",
              "code": "// Function to test\npub fn add(left: usize, right: usize) -> usize {\n    left + right\n}\n\npub fn greeting(name: &str) -> String {\n    format!(\"Hello {name}!\")\n}\n\n// Unit tests (in the same file)\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn it_works() {\n        let result = add(2, 2);\n        assert_eq!(result, 4);\n    }\n    \n    #[test]\n    fn greeting_contains_name() {\n        let result = greeting(\"Carol\");\n        assert!(\n            result.contains(\"Carol\"),\n            \"Greeting did not contain name, value was `{result}`\"\n        );\n    }\n    \n    #[test]\n    #[should_panic(expected = \"less than or equal to 100\")]\n    fn greater_than_100() {\n        // This should panic\n        Guess::new(200);\n    }\n    \n    #[test]\n    fn it_works_with_result() -> Result<(), String> {\n        if add(2, 2) == 4 {\n            Ok(())\n        } else {\n            Err(String::from(\"two plus two does not equal four\"))\n        }\n    }\n}\n\n// Code that should panic\npub struct Guess {\n    value: i32,\n}\n\nimpl Guess {\n    pub fn new(value: i32) -> Guess {\n        if value < 1 {\n            panic!(\"Guess value must be greater than or equal to 1, got {value}.\");\n        } else if value > 100 {\n            panic!(\"Guess value must be less than or equal to 100, got {value}.\");\n        }\n        \n        Guess { value }\n    }\n}\n\n// Running tests:\n// cargo test              # Run all tests\n// cargo test it_works     # Run specific test\n// cargo test -- --ignored # Run ignored tests\n// cargo test -- --show-output # Show println! output"
            }
          }
        ]
      },
      {
        "id": "iterators-closures",
        "title": "Iterators & Closures",
        "slides": [
          {
            "type": "topic-title",
            "title": "Functional Programming Features"
          },
          {
            "type": "content",
            "emoji": "üîÑ",
            "title": "Closures",
            "box": {
              "content": "<strong>Anonymous functions</strong>",
              "code": "fn main() {\n    // Basic closure\n    let add_one = |x| x + 1;\n    println!(\"5 + 1 = {}\", add_one(5));\n    \n    // Closure with multiple parameters\n    let add = |x, y| x + y;\n    println!(\"3 + 4 = {}\", add(3, 4));\n    \n    // Capturing environment\n    let x = 4;\n    let equal_to_x = |z| z == x;  // Borrows x immutably\n    let y = 4;\n    assert!(equal_to_x(y));\n    \n    // Moving ownership into closure\n    let x = vec![1, 2, 3];\n    let equal_to_x = move |z| z == x;  // x is moved into closure\n    // println!(\"{:?}\", x);  // Error: x was moved\n    \n    // Closures as function parameters\n    let numbers = vec![1, 2, 3, 4, 5];\n    let doubled: Vec<i32> = numbers.iter().map(|x| x * 2).collect();\n    println!(\"Doubled: {:?}\", doubled);\n}\n\n// Function that takes a closure\nfn apply<F>(f: F, value: i32) -> i32\nwhere\n    F: Fn(i32) -> i32,\n{\n    f(value)\n}\n\nfn main() {\n    let double = |x| x * 2;\n    let result = apply(double, 5);\n    println!(\"Result: {result}\");\n}\n\n// Three types of closures:\n// Fn: borrows values immutably\n// FnMut: borrows values mutably  \n// FnOnce: takes ownership of values"
            }
          },
          {
            "type": "content",
            "emoji": "üåÄ",
            "title": "Iterators",
            "box": {
              "content": "<strong>Processing sequences</strong>",
              "code": "fn main() {\n    let v1 = vec![1, 2, 3];\n    \n    // Creating iterators\n    let v1_iter = v1.iter();        // Immutable references\n    // let v1_iter = v1.into_iter(); // Takes ownership\n    // let v1_iter = v1.iter_mut();  // Mutable references\n    \n    // Using iterator in for loop\n    for val in v1_iter {\n        println!(\"Got: {val}\");\n    }\n    \n    // Iterator adaptors (produce new iterators)\n    let v1 = vec![1, 2, 3];\n    let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();\n    println!(\"v2: {:?}\", v2);\n    \n    // Consuming adaptors\n    let v1 = vec![1, 2, 3];\n    let total: i32 = v1.iter().sum();\n    println!(\"Sum: {total}\");\n    \n    // Chaining methods\n    let names = vec![\"alice\", \"bob\", \"carol\"];\n    let uppercase_names: Vec<String> = names\n        .iter()\n        .map(|name| name.to_uppercase())\n        .filter(|name| name.contains('A'))\n        .collect();\n    println!(\"Uppercase names with 'A': {:?}\", uppercase_names);\n    \n    // Using enumerate\n    for (index, value) in v1.iter().enumerate() {\n        println!(\"Index: {index}, Value: {value}\");\n    }\n}\n\n// Creating custom iterator\nstruct Counter {\n    count: u32,\n}\n\nimpl Counter {\n    fn new() -> Counter {\n        Counter { count: 0 }\n    }\n}\n\nimpl Iterator for Counter {\n    type Item = u32;\n    \n    fn next(&mut self) -> Option<Self::Item> {\n        if self.count < 5 {\n            self.count += 1;\n            Some(self.count)\n        } else {\n            None\n        }\n    }\n}\n\nfn main() {\n    let mut counter = Counter::new();\n    for num in counter {\n        println!(\"Counter: {num}\");\n    }\n}"
            }
          }
        ]
      },
      {
        "id": "smart-pointers",
        "title": "Smart Pointers",
        "slides": [
          {
            "type": "topic-title",
            "title": "Smart Pointers"
          },
          {
            "type": "content",
            "emoji": "üìå",
            "title": "Box, Rc, RefCell",
            "box": {
              "content": "<strong>Pointers with extra capabilities</strong>",
              "code": "use std::rc::Rc;\nuse std::cell::RefCell;\n\nfn main() {\n    // Box<T> for heap allocation\n    let b = Box::new(5);\n    println!(\"b = {b}\");\n    \n    // Recursive types with Box\n    #[derive(Debug)]\n    enum List {\n        Cons(i32, Box<List>),\n        Nil,\n    }\n    \n    let list = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));\n    println!(\"List: {:?}\", list);\n    \n    // Rc<T> for reference counting\n    let a = Rc::new(List::Cons(5, Box::new(List::Nil)));\n    println!(\"Reference count after creating a = {}\", Rc::strong_count(&a));\n    let b = List::Cons(3, Box::new(a));\n    let c = List::Cons(4, Box::new(a));\n    println!(\"Reference count after creating b and c = {}\", Rc::strong_count(&a));\n    \n    // RefCell<T> for interior mutability\n    let x = RefCell::new(42);\n    {\n        let mut y = x.borrow_mut();\n        *y += 1;\n    }\n    println!(\"x = {:?}\", x.borrow());\n    \n    // Combination: Rc<RefCell<T>>\n    let value = Rc::new(RefCell::new(5));\n    let a = Rc::clone(&value);\n    let b = Rc::clone(&value);\n    \n    *a.borrow_mut() += 10;\n    *b.borrow_mut() += 20;\n    \n    println!(\"Final value: {:?}\", *value.borrow());\n}\n\n// Deref trait\nuse std::ops::Deref;\n\nstruct MyBox<T>(T);\n\nimpl<T> MyBox<T> {\n    fn new(x: T) -> MyBox<T> {\n        MyBox(x)\n    }\n}\n\nimpl<T> Deref for MyBox<T> {\n    type Target = T;\n    \n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n\nfn hello(name: &str) {\n    println!(\"Hello, {name}!\");\n}\n\nfn main() {\n    let m = MyBox::new(String::from(\"Rust\"));\n    hello(&m);  // Deref coercion: &MyBox<String> -> &String -> &str\n}"
            }
          }
        ]
      },
      {
        "id": "concurrency",
        "title": "Concurrency",
        "slides": [
          {
            "type": "topic-title",
            "title": "Fearless Concurrency"
          },
          {
            "type": "content",
            "emoji": "üîÑ",
            "title": "Threads",
            "box": {
              "content": "<strong>Parallel execution with threads</strong>",
              "code": "use std::thread;\nuse std::time::Duration;\nuse std::sync::{mpsc, Mutex, Arc};\n\nfn main() {\n    // Spawning a thread\n    let handle = thread::spawn(|| {\n        for i in 1..10 {\n            println!(\"hi number {i} from the spawned thread!\");\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n    \n    for i in 1..5 {\n        println!(\"hi number {i} from the main thread!\");\n        thread::sleep(Duration::from_millis(1));\n    }\n    \n    handle.join().unwrap();  // Wait for thread to finish\n    \n    // Moving ownership into thread\n    let v = vec![1, 2, 3];\n    let handle = thread::spawn(move || {\n        println!(\"Here's a vector: {:?}\", v);\n    });\n    handle.join().unwrap();\n    \n    // Message passing with channels\n    let (tx, rx) = mpsc::channel();\n    \n    let tx1 = tx.clone();\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"hi\"),\n            String::from(\"from\"),\n            String::from(\"the\"),\n            String::from(\"thread\"),\n        ];\n        \n        for val in vals {\n            tx1.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n    \n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"more\"),\n            String::from(\"messages\"),\n            String::from(\"for\"),\n            String::from(\"you\"),\n        ];\n        \n        for val in vals {\n            tx.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n    \n    for received in rx {\n        println!(\"Got: {received}\");\n    }\n    \n    // Shared state with Mutex\n    let counter = Arc::new(Mutex::new(0));\n    let mut handles = vec![];\n    \n    for _ in 0..10 {\n        let counter = Arc::clone(&counter);\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n    \n    for handle in handles {\n        handle.join().unwrap();\n    }\n    \n    println!(\"Result: {}\", *counter.lock().unwrap());\n}"
            }
          }
        ]
      },
      {
        "id": "async-rust",
        "title": "Async Rust",
        "slides": [
          {
            "type": "topic-title",
            "title": "Asynchronous Programming"
          },
          {
            "type": "content",
            "emoji": "‚ö°",
            "title": "Async/Await",
            "box": {
              "content": "<strong>Writing asynchronous code</strong>",
              "code": "// Add to Cargo.toml:\n// [dependencies]\n// tokio = { version = \"1.0\", features = [\"full\"] }\n\nuse tokio::time::{sleep, Duration};\n\n// Async function\nasync fn hello_world() {\n    println!(\"hello world\");\n}\n\n// Async function that takes time\nasync fn learn_song() -> String {\n    sleep(Duration::from_secs(2)).await;\n    String::from(\"Rust song\")\n}\n\nasync fn sing_song(song: String) {\n    println!(\"Singing: {song}\");\n}\n\nasync fn dance() {\n    println!(\"Dancing!\");\n}\n\n// Sequential execution\nasync fn learn_and_sing() {\n    let song = learn_song().await;\n    sing_song(song).await;\n}\n\n// Concurrent execution\nasync fn async_main() {\n    let f1 = learn_and_sing();\n    let f2 = dance();\n    \n    // Execute both concurrently\n    tokio::join!(f1, f2);\n}\n\n#[tokio::main]\nasync fn main() {\n    hello_world().await;\n    async_main().await;\n    \n    // Spawning tasks\n    let handle = tokio::spawn(async {\n        // some async work\n        \"hello from async task\"\n    });\n    \n    let result = handle.await.unwrap();\n    println!(\"{result}\");\n    \n    // Async HTTP request with reqwest\n    // let body = reqwest::get(\"https://www.rust-lang.org\")\n    //     .await?\n    //     .text()\n    //     .await?;\n    // println!(\"body = {body}\");\n}\n\n// Manual future implementation\nuse std::future::Future;\nuse std::pin::Pin;\nuse std::task::{Context, Poll};\n\nstruct Timer {\n    duration: Duration,\n    elapsed: bool,\n}\n\nimpl Future for Timer {\n    type Output = ();\n    \n    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n        if self.elapsed {\n            Poll::Ready(())\n        } else {\n            self.elapsed = true;\n            let waker = cx.waker().clone();\n            tokio::spawn(async move {\n                sleep(self.duration).await;\n                waker.wake();\n            });\n            Poll::Pending\n        }\n    }\n}"
            }
          }
        ]
      },
      {
        "id": "real-world-apps",
        "title": "Real World Applications",
        "slides": [
          {
            "type": "topic-title",
            "title": "Rust in Production"
          },
          {
            "type": "content",
            "emoji": "üåê",
            "title": "Web Development",
            "box": {
              "content": "<strong>Building web services</strong>",
              "code": "// Add to Cargo.toml:\n// [dependencies]\n// axum = \"0.6\"\n// tokio = { version = \"1.0\", features = [\"full\"] }\n// serde = { version = \"1.0\", features = [\"derive\"] }\n\nuse axum::{\n    routing::{get, post},\n    Json, Router,\n};\nuse serde::{Deserialize, Serialize};\nuse std::net::SocketAddr;\n\n#[derive(Serialize, Deserialize)]\nstruct User {\n    id: u64,\n    username: String,\n    email: String,\n}\n\n#[tokio::main]\nasync fn main() {\n    // Build our application with routes\n    let app = Router::new()\n        .route(\"/\", get(root))\n        .route(\"/users\", get(get_users).post(create_user))\n        .route(\"/users/:id\", get(get_user));\n    \n    // Run it\n    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));\n    println!(\"Listening on {addr}\");\n    axum::Server::bind(&addr)\n        .serve(app.into_make_service())\n        .await\n        .unwrap();\n}\n\n// Handler functions\nasync fn root() -> &'static str {\n    \"Hello, World!\"\n}\n\nasync fn get_users() -> Json<Vec<User>> {\n    Json(vec![\n        User {\n            id: 1,\n            username: \"alice\".to_string(),\n            email: \"alice@example.com\".to_string(),\n        },\n        User {\n            id: 2,\n            username: \"bob\".to_string(),\n            email: \"bob@example.com\".to_string(),\n        },\n    ])\n}\n\nasync fn get_user(axum::extract::Path(id): axum::extract::Path<u64>) -> Json<User> {\n    Json(User {\n        id,\n        username: \"user\".to_string(),\n        email: \"user@example.com\".to_string(),\n    })\n}\n\nasync fn create_user(Json(user): Json<User>) -> Json<User> {\n    Json(user)\n}\n\n// Popular web frameworks:\n// - Axum: Tokio team's framework\n// - Actix-web: High performance\n// - Rocket: Easy to use, macros\n// - Warp: Filter-based"
            }
          },
          {
            "type": "content",
            "emoji": "üîß",
            "title": "CLI Tools",
            "box": {
              "content": "<strong>Command-line applications</strong>",
              "code": "// Add to Cargo.toml:\n// [dependencies]\n// clap = { version = \"4.0\", features = [\"derive\"] }\n// anyhow = \"1.0\"\n// tokio = { version = \"1.0\", features = [\"full\"] }\n\nuse clap::{Parser, Subcommand};\nuse std::path::PathBuf;\n\n#[derive(Parser)]\n#[command(name = \"myapp\")]\n#[command(about = \"A simple CLI tool\", long_about = None)]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n    \n    #[arg(short, long, action = clap::ArgAction::Count)]\n    verbose: u8,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    /// Count lines in a file\n    Count {\n        #[arg(short, long)]\n        file: PathBuf,\n    },\n    /// Search for pattern in file\n    Search {\n        #[arg(short, long)]\n        pattern: String,\n        #[arg(short, long)]\n        file: PathBuf,\n    },\n}\n\nfn main() -> anyhow::Result<()> {\n    let cli = Cli::parse();\n    \n    if cli.verbose > 0 {\n        println!(\"Verbose mode enabled at level {}\", cli.verbose);\n    }\n    \n    match cli.command {\n        Commands::Count { file } => {\n            let content = std::fs::read_to_string(file)?;\n            let lines = content.lines().count();\n            println!(\"Lines: {lines}\");\n        }\n        Commands::Search { pattern, file } => {\n            let content = std::fs::read_to_string(file)?;\n            for (line_num, line) in content.lines().enumerate() {\n                if line.contains(&pattern) {\n                    println!(\"{}: {}\", line_num + 1, line);\n                }\n            }\n        }\n    }\n    \n    Ok(())\n}\n\n// Popular CLI libraries:\n// - clap: Most popular, feature-rich\n// - structopt: clap predecessor\n// - gumdrop: Simple alternative"
            }
          }
        ]
      },
      {
        "id": "webassembly",
        "title": "WebAssembly",
        "slides": [
          {
            "type": "topic-title",
            "title": "Rust for WebAssembly"
          },
          {
            "type": "content",
            "emoji": "üï∏Ô∏è",
            "title": "WASM with Rust",
            "box": {
              "content": "<strong>Compiling to WebAssembly</strong>",
              "code": "// Add to Cargo.toml:\n// [lib]\n// crate-type = [\"cdylib\"]\n// \n// [dependencies]\n// wasm-bindgen = \"0.2\"\n\nuse wasm_bindgen::prelude::*;\n\n// Export a function to JavaScript\n#[wasm_bindgen]\npub fn greet(name: &str) -> String {\n    format!(\"Hello, {}!\", name)\n}\n\n// Export a struct to JavaScript\n#[wasm_bindgen]\npub struct Counter {\n    count: i32,\n}\n\n#[wasm_bindgen]\nimpl Counter {\n    #[wasm_bindgen(constructor)]\n    pub fn new() -> Self {\n        Self { count: 0 }\n    }\n    \n    pub fn increment(&mut self) {\n        self.count += 1;\n    }\n    \n    pub fn get_count(&self) -> i32 {\n        self.count\n    }\n}\n\n// Using console.log from Rust\n#[wasm_bindgen]\nextern \"C\" {\n    #[wasm_bindgen(js_namespace = console)]\n    fn log(s: &str);\n}\n\n#[wasm_bindgen]\npub fn debug_message(message: &str) {\n    log(&format!(\"Debug: {}\", message));\n}\n\n// Build commands:\n// # Install wasm-pack\n// cargo install wasm-pack\n// \n// # Build for web\n// wasm-pack build --target web\n// \n// # Or for Node.js\n// wasm-pack build --target nodejs\n\n// HTML usage example:\n/*\n<!DOCTYPE html>\n<html>\n  <body>\n    <script type=\"module\">\n      import init, { greet, Counter } from './pkg/your_crate.js';\n      \n      async function run() {\n        await init();\n        \n        console.log(greet('World'));\n        \n        const counter = new Counter();\n        counter.increment();\n        console.log(counter.get_count()); // 1\n      }\n      \n      run();\n    </script>\n  </body>\n</html>\n*/"
            }
          }
        ]
      },
      {
        "id": "embedded",
        "title": "Embedded Rust",
        "slides": [
          {
            "type": "topic-title",
            "title": "Rust for Embedded Systems"
          },
          {
            "type": "content",
            "emoji": "üìü",
            "title": "no_std Programming",
            "box": {
              "content": "<strong>Bare-metal Rust</strong>",
              "code": "// Add to Cargo.toml:\n// [dependencies]\n// cortex-m = \"0.7\"\n// cortex-m-rt = \"0.7\"\n// panic-halt = \"0.2\"\n\n#![no_std]  // Disable standard library\n#![no_main] // Disable main interface\n\nuse cortex_m_rt::entry;\nuse panic_halt as _;\n\n// Custom panic handler\n#[panic_handler]\nfn panic(_info: &core::panic::PanicInfo) -> ! {\n    loop {}\n}\n\n// Entry point for Cortex-M\n#[entry]\nfn main() -> ! {\n    // Your embedded code here\n    \n    // Blink LED example (pseudo-code)\n    // unsafe {\n    //     // Configure GPIO\n    //     let rcc = &(*stm32::RCC::ptr());\n    //     rcc.ahb2enr.modify(|_, w| w.gpioben().set_bit());\n    //     \n    //     let gpio = &(*stm32::GPIOB::ptr());\n    //     gpio.moder.modify(|_, w| w.moder0().output());\n    //     \n    //     loop {\n    //         gpio.bsrr.write(|w| w.bs0().set_bit());  // LED on\n    //         delay(1_000_000);\n    //         gpio.bsrr.write(|w| w.br0().set_bit());  // LED off\n    //         delay(1_000_000);\n    //     }\n    // }\n    \n    loop {}\n}\n\n// Delay function\nfn delay(count: u32) {\n    for _ in 0..count {\n        cortex_m::asm::nop();\n    }\n}\n\n// Memory allocation in no_std\n#![feature(alloc_error_handler)]\n\nextern crate alloc;\nuse alloc::vec::Vec;\n\n#[global_allocator]\nstatic ALLOCATOR: embedded_alloc::Heap = embedded_alloc::Heap::empty();\n\nfn init_heap() {\n    // Initialize heap with memory region\n    const HEAP_SIZE: usize = 1024;\n    static mut HEAP: [u8; HEAP_SIZE] = [0; HEAP_SIZE];\n    \n    unsafe {\n        ALLOCATOR.init(HEAP.as_ptr() as usize, HEAP_SIZE);\n    }\n}\n\n// Popular embedded crates:\n// - cortex-m: ARM Cortex-M support\n// - embedded-hal: Hardware abstraction\n// - nb: Non-blocking I/O\n// - heapless: No-std collections"
            }
          }
        ]
      },
      {
        "id": "unsafe-rust",
        "title": "Unsafe Rust",
        "slides": [
          {
            "type": "topic-title",
            "title": "Unsafe Rust"
          },
          {
            "type": "content",
            "emoji": "‚ö†Ô∏è",
            "title": "When and How to Use Unsafe",
            "box": {
              "content": "<strong>Bypassing compiler checks</strong>",
              "code": "// Unsafe Rust allows you to:\n// 1. Dereference raw pointers\n// 2. Call unsafe functions\n// 3. Access or modify mutable static variables\n// 4. Implement unsafe traits\n\nfn main() {\n    // Raw pointers\n    let mut num = 5;\n    \n    let r1 = &num as *const i32;     // Immutable raw pointer\n    let r2 = &mut num as *mut i32;   // Mutable raw pointer\n    \n    unsafe {\n        println!(\"r1 is: {}\", *r1);\n        println!(\"r2 is: {}\", *r2);\n        \n        *r2 = 10;\n        println!(\"After mutation: {}\", *r1);\n    }\n    \n    // Calling unsafe functions\n    unsafe fn dangerous() {}\n    \n    unsafe {\n        dangerous();\n    }\n    \n    // Creating safe abstractions over unsafe code\n    let mut v = vec![1, 2, 3, 4, 5, 6];\n    \n    let r = &mut v[..];\n    \n    let (a, b) = r.split_at_mut(3);\n    \n    assert_eq!(a, &mut [1, 2, 3]);\n    assert_eq!(b, &mut [4, 5, 6]);\n}\n\n// Safe abstraction over unsafe code\nfn split_at_mut(slice: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {\n    let len = slice.len();\n    let ptr = slice.as_mut_ptr();\n    \n    assert!(mid <= len);\n    \n    unsafe {\n        (\n            std::slice::from_raw_parts_mut(ptr, mid),\n            std::slice::from_raw_parts_mut(ptr.add(mid), len - mid),\n        )\n    }\n}\n\n// Foreign Function Interface (FFI)\n#[repr(C)]\npub struct Point {\n    x: i32,\n    y: i32,\n}\n\n// Import C function\nextern \"C\" {\n    fn abs(input: i32) -> i32;\n}\n\n// Export Rust function to C\n#[no_mangle]\npub extern \"C\" fn rust_function(x: i32) -> i32 {\n    x * 2\n}\n\nfn main() {\n    unsafe {\n        println!(\"Absolute value of -3 according to C: {}\", abs(-3));\n    }\n}\n\n// Guidelines for unsafe code:\n// - Keep unsafe blocks small\n// - Document why unsafe is needed\n// - Prefer safe abstractions\n// - Test thoroughly"
            }
          }
        ]
      },
      {
        "id": "career-learning",
        "title": "Career & Learning",
        "slides": [
          {
            "type": "topic-title",
            "title": "Rust Career Path"
          },
          {
            "type": "content",
            "emoji": "üíº",
            "title": "Job Opportunities",
            "box": {
              "list": [
                {
                  "emoji": "üîß",
                  "text": "<strong>Systems Programmer</strong> - OS, drivers, embedded"
                },
                {
                  "emoji": "üåê",
                  "text": "<strong>Backend Developer</strong> - Web services, APIs"
                },
                {
                  "emoji": "üì¶",
                  "text": "<strong>Blockchain Developer</strong> - Smart contracts, protocols"
                },
                {
                  "emoji": "üï∏Ô∏è",
                  "text": "<strong>WebAssembly Developer</strong> - Frontend performance"
                },
                {
                  "emoji": "üîí",
                  "text": "<strong>Security Engineer</strong> - Security-critical applications"
                },
                {
                  "emoji": "üìö",
                  "text": "<strong>Tooling Developer</strong> - Compilers, dev tools"
                }
              ]
            }
          },
          {
            "type": "content",
            "emoji": "üìñ",
            "title": "Learning Resources",
            "box": {
              "list": [
                {
                  "emoji": "üìö",
                  "text": "<strong>The Rust Book</strong> - Official comprehensive guide"
                },
                {
                  "emoji": "üéØ",
                  "text": "<strong>Rust by Example</strong> - Learn by doing"
                },
                {
                  "emoji": "üî¨",
                  "text": "<strong>Rustlings</strong> - Small exercises to practice"
                },
                {
                  "emoji": "üèÜ",
                  "text": "<strong>Advent of Code</strong> - Programming challenges"
                },
                {
                  "emoji": "üí¨",
                  "text": "<strong>Rust Users Forum</strong> - Community support"
                },
                {
                  "emoji": "üì∫",
                  "text": "<strong>YouTube Channels</strong> - Let's Get Rusty, No Boilerplate"
                }
              ]
            }
          }
        ]
      },
      {
        "id": "cheat-sheet",
        "title": "Cheat Sheet",
        "slides": [
          {
            "type": "content",
            "emoji": "üìã",
            "title": "Rust Quick Reference",
            "box": {
              "content": "<strong>Essential Rust syntax</strong>",
              "code": "// Variables & Types\nlet x = 5;                    // Immutable\nlet mut y = 5;                // Mutable\nconst MAX: u32 = 100_000;     // Constant\n\n// Functions\nfn add(x: i32, y: i32) -> i32 { x + y }\n\n// Control Flow\nif condition { } else { }\nwhile condition { }\nfor item in collection { }\nloop { break; }\n\n// Pattern Matching\nmatch value {\n    Pattern => expression,\n    _ => default,\n}\n\n// Error Handling\nlet result: Result<T, E> = function();\nlet value = result?;          // Propagate error\nlet value = result.unwrap();  // Panic on error\n\n// Collections\nlet v = vec![1, 2, 3];       // Vector\nlet s = String::from(\"hello\"); // String\nlet m = HashMap::new();       // Hash Map\n\n// Ownership & Borrowing\nlet s1 = String::from(\"hello\");\nlet s2 = s1;                  // Move (s1 invalidated)\nlet s3 = &s2;                 // Borrow (immutable)\nlet s4 = &mut s2;             // Borrow (mutable)\n\n// Common Traits\nDebug, Display, Clone, Copy, \nPartialEq, Eq, PartialOrd, Ord,\nHash, Default, From, Into\n\n// Macros\nprintln!(\"Hello {}\", name);   // Print formatting\nvec![1, 2, 3];               // Vector creation\n#[derive(Debug)]             // Derive macro"
            }
          }
        ]
      },
      {
        "id": "hands-on-project",
        "title": "Hands-On Project",
        "slides": [
          {
            "type": "content",
            "emoji": "üî®",
            "title": "Mini Project: Build a CLI Tool",
            "box": {
              "list": [
                {
                  "emoji": "1Ô∏è‚É£",
                  "text": "Create new project with cargo new"
                },
                {
                  "emoji": "2Ô∏è‚É£",
                  "text": "Add dependencies (clap, anyhow, tokio)"
                },
                {
                  "emoji": "3Ô∏è‚É£",
                  "text": "Implement file reading and parsing"
                },
                {
                  "emoji": "4Ô∏è‚É£",
                  "text": "Add error handling with Result"
                },
                {
                  "emoji": "5Ô∏è‚É£",
                  "text": "Write unit tests"
                },
                {
                  "emoji": "6Ô∏è‚É£",
                  "text": "Add command-line arguments"
                },
                {
                  "emoji": "7Ô∏è‚É£",
                  "text": "Implement async features"
                },
                {
                  "emoji": "8Ô∏è‚É£",
                  "text": "Build and distribute"
                }
              ]
            }
          }
        ]
      },
      {
        "id": "quiz",
        "title": "Quick Quiz",
        "slides": [
          {
            "type": "content",
            "emoji": "üß†",
            "title": "Test Your Knowledge",
            "box": {
              "list": [
                {
                  "emoji": "1Ô∏è‚É£",
                  "text": "What are the three rules of ownership?"
                },
                {
                  "emoji": "2Ô∏è‚É£",
                  "text": "How do you handle errors in Rust?"
                },
                {
                  "emoji": "3Ô∏è‚É£",
                  "text": "What's the difference between String and &str?"
                },
                {
                  "emoji": "4Ô∏è‚É£",
                  "text": "When would you use Box<T> vs Rc<T>?"
                },
                {
                  "emoji": "5Ô∏è‚É£",
                  "text": "What problem do lifetimes solve?"
                }
              ]
            }
          }
        ]
      },
      {
        "id": "recap",
        "title": "Quick Recap",
        "slides": [
          {
            "type": "content",
            "emoji": "üìù",
            "title": "Key Takeaways",
            "box": {
              "list": [
                {
                  "emoji": "‚ö°",
                  "text": "Rust = Performance + Safety + Concurrency"
                },
                {
                  "emoji": "üîí",
                  "text": "Ownership system prevents memory errors"
                },
                {
                  "emoji": "üöÄ",
                  "text": "Zero-cost abstractions for C++ level performance"
                },
                {
                  "emoji": "üîÑ",
                  "text": "Fearless concurrency with compile-time checks"
                },
                {
                  "emoji": "üìö",
                  "text": "Excellent tooling and package management"
                },
                {
                  "emoji": "üåê",
                  "text": "Versatile: systems, web, embedded, WASM"
                }
              ]
            }
          }
        ]
      },
      {
        "id": "qa-and-thank-you",
        "title": "Q&A and Thank You",
        "slides": [
          {
            "type": "qa",
            "title": "Questions? üí¨",
            "content": "Let's discuss Rust concepts, ownership, or specific use cases!<br><span class=\"gradient-accent\">All Rust questions welcome!</span>"
          },
          {
            "type": "thank-you",
            "title": "Thank You! üéâ",
            "box": {
              "content": "<span class=\"emoji\">ü¶Ä</span> Ready to master Rust?<br><span class=\"gradient-accent\">Start your Rust journey today!</span>",
              "note": "Safe ‚Ä¢ Fast ‚Ä¢ Productive"
            },
            "footer": {
              "org": "Bude Global Enterprise - India",
              "tagline": "Empowering developers worldwide"
            }
          }
        ]
      }
    ]
  }
}