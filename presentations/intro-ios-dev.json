{
  "presentation": {
    "topics": [
      {
        "id": "title",
        "title": "Title Slide",
        "slides": [
          {
            "type": "title",
            "title": "iOS Advanced Development",
            "subtitle": "SwiftUI + UIKit Deep Dive<br>Professional-Grade iOS Applications"
          }
        ]
      },
      {
        "id": "presenter",
        "title": "Presenter Slide",
        "slides": [
          {
            "type": "presenter",
            "name": "Aravind Govindhasamy",
            "title": "iOS Developer",
            "experience": "4 years in iOS Development, Swift, SwiftUI & UIKit",
            "oss_experience": "Mobile Architecture & Performance Specialist",
            "github": "https://github.com/aravind-govindhasamy",
            "website": "https://aravind-govindhasamy.github.io"
          }
        ]
      },
      {
        "id": "agenda",
        "title": "Agenda",
        "slides": [
          {
            "type": "content",
            "title": "What We'll Cover",
            "box": {
              "list": [
                {
                  "emoji": "üöÄ",
                  "text": "<strong>Modern iOS Architecture</strong> - SwiftUI + UIKit"
                },
                {
                  "emoji": "üÜö",
                  "text": "<strong>SwiftUI vs UIKit</strong> - Comparative Analysis"
                },
                {
                  "emoji": "üîó",
                  "text": "<strong>Framework Integration</strong> - Seamless Bridging"
                },
                {
                  "emoji": "üé®",
                  "text": "<strong>Advanced SwiftUI</strong> - Layouts & Animations"
                },
                {
                  "emoji": "üèóÔ∏è",
                  "text": "<strong>UIKit Fundamentals</strong> - Advanced Techniques"
                },
                {
                  "emoji": "‚ö°",
                  "text": "<strong>Combine Framework</strong> - Reactive Programming"
                },
                {
                  "emoji": "üß≠",
                  "text": "<strong>Navigation & State</strong> - Modern Patterns"
                },
                {
                  "emoji": "üí´",
                  "text": "<strong>Animations</strong> - SwiftUI & Core Animation"
                },
                {
                  "emoji": "üíæ",
                  "text": "<strong>Data Persistence</strong> - Core Data & SwiftData"
                },
                {
                  "emoji": "üåê",
                  "text": "<strong>Networking</strong> - Async/Await & URLSession"
                },
                {
                  "emoji": "üì±",
                  "text": "<strong>Multi-Platform</strong> - iPadOS & watchOS"
                },
                {
                  "emoji": "‚ö°",
                  "text": "<strong>Performance</strong> - Optimization & Profiling"
                },
                {
                  "emoji": "üß™",
                  "text": "<strong>Testing</strong> - XCTest & UI Testing"
                },
                {
                  "emoji": "‚ôø",
                  "text": "<strong>Accessibility</strong> - Inclusive Design"
                },
                {
                  "emoji": "üèõÔ∏è",
                  "text": "<strong>Architecture</strong> - MVVM, TCA, Clean Arch"
                },
                {
                  "emoji": "üöÄ",
                  "text": "<strong>Deployment</strong> - CI/CD & App Store"
                }
              ]
            }
          }
        ]
      },
      {
        "id": "introduction",
        "title": "Introduction",
        "slides": [
          {
            "type": "topic-title",
            "title": "Advanced iOS Development"
          },
          {
            "type": "content",
            "emoji": "üöÄ",
            "title": "Modern iOS Architecture",
            "box": {
              "content": "<span class=\"highlight\">Hybrid Approach: SwiftUI + UIKit + Combine</span>",
              "list": [
                {
                  "emoji": "üéØ",
                  "text": "<strong>SwiftUI</strong> - Declarative UI framework"
                },
                {
                  "emoji": "üèóÔ∏è",
                  "text": "<strong>UIKit</strong> - Mature imperative framework"
                },
                {
                  "emoji": "‚ö°",
                  "text": "<strong>Combine</strong> - Reactive programming"
                },
                {
                  "emoji": "üîó",
                  "text": "<strong>Seamless Integration</strong> - Best of both worlds"
                },
                {
                  "emoji": "üí™",
                  "text": "<strong>Performance</strong> - Optimized for each use case"
                }
              ]
            },
            "note": {
              "text": "<strong>Pro tip:</strong> Most professional apps use a hybrid approach for maximum flexibility and performance!"
            }
          }
        ]
      },
      {
        "id": "swiftui-vs-uikit",
        "title": "SwiftUI vs UIKit",
        "slides": [
          {
            "type": "topic-title",
            "title": "Framework Comparison"
          },
          {
            "type": "content",
            "emoji": "üÜö",
            "title": "SwiftUI vs UIKit - Architecture",
            "box": {
              "list": [
                {
                  "emoji": "üéØ",
                  "text": "<strong>SwiftUI</strong> - Declarative, state-driven"
                },
                {
                  "emoji": "üèóÔ∏è",
                  "text": "<strong>UIKit</strong> - Imperative, event-driven"
                },
                {
                  "emoji": "üöÄ",
                  "text": "<strong>SwiftUI</strong> - Automatic updates, less code"
                },
                {
                  "emoji": "üîß",
                  "text": "<strong>UIKit</strong> - Manual updates, full control"
                },
                {
                  "emoji": "üì±",
                  "text": "<strong>SwiftUI</strong> - iOS 13+, cross-platform"
                },
                {
                  "emoji": "üì±",
                  "text": "<strong>UIKit</strong> - iOS 2+, mature ecosystem"
                }
              ]
            }
          },
          {
            "type": "content",
            "emoji": "üéØ",
            "title": "When to Use Each",
            "box": {
              "list": [
                {
                  "emoji": "‚úÖ",
                  "text": "<strong>SwiftUI</strong> - New projects, iOS 13+ target"
                },
                {
                  "emoji": "‚úÖ",
                  "text": "<strong>UIKit</strong> - Large codebases, complex custom UI"
                },
                {
                  "emoji": "‚úÖ",
                  "text": "<strong>Hybrid</strong> - Incremental migration, best features"
                },
                {
                  "emoji": "‚ùå",
                  "text": "<strong>SwiftUI</strong> - Avoid for highly custom drawing"
                },
                {
                  "emoji": "‚ùå",
                  "text": "<strong>UIKit</strong> - Avoid for new iOS-only projects"
                }
              ]
            }
          }
        ]
      },
      {
        "id": "integration",
        "title": "Framework Integration",
        "slides": [
          {
            "type": "topic-title",
            "title": "SwiftUI + UIKit Integration"
          },
          {
            "type": "content",
            "emoji": "üîó",
            "title": "Bridging Techniques",
            "box": {
              "content": "<strong>Seamless Integration Patterns</strong>",
              "code": "import SwiftUI\nimport UIKit\n\n// UIKit in SwiftUI - UIViewRepresentable\nstruct MyUILabel: UIViewRepresentable {\n    var text: String\n    \n    func makeUIView(context: Context) -> UILabel {\n        let label = UILabel()\n        label.text = text\n        return label\n    }\n    \n    func updateUIView(_ uiView: UILabel, context: Context) {\n        uiView.text = text\n    }\n}\n\n// SwiftUI in UIKit - UIHostingController\nclass MyViewController: UIViewController {\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        let swiftUIView = MySwiftUIView()\n        let hostingController = UIHostingController(rootView: swiftUIView)\n        \n        addChild(hostingController)\n        view.addSubview(hostingController.view)\n        hostingController.didMove(toParent: self)\n        \n        // AutoLayout constraints\n        hostingController.view.translatesAutoresizingMaskIntoConstraints = false\n        NSLayoutConstraint.activate([\n            hostingController.view.leadingAnchor.constraint(equalTo: view.leadingAnchor),\n            hostingController.view.trailingAnchor.constraint(equalTo: view.trailingAnchor),\n            hostingController.view.topAnchor.constraint(equalTo: view.topAnchor),\n            hostingController.view.bottomAnchor.constraint(equalTo: view.bottomAnchor)\n        ])\n    }\n}"
            }
          },
          {
            "type": "content",
            "emoji": "üîÑ",
            "title": "Data Flow Between Frameworks",
            "box": {
              "content": "<strong>Coordinating State and Data</strong>",
              "code": "import SwiftUI\nimport Combine\n\n// Shared ViewModel\nclass SharedViewModel: ObservableObject {\n    @Published var userData: UserData = UserData()\n    @Published var isLoading: Bool = false\n}\n\n// UIKit Component using SwiftUI ViewModel\nclass UIKitViewController: UIViewController {\n    var viewModel: SharedViewModel!\n    private var cancellables = Set<AnyCancellable>()\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupBindings()\n    }\n    \n    private func setupBindings() {\n        viewModel.$userData\n            .receive(on: DispatchQueue.main)\n            .sink { [weak self] userData in\n                self?.updateUI(with: userData)\n            }\n            .store(in: &cancellables)\n    }\n    \n    private func updateUI(with userData: UserData) {\n        // Update UIKit components\n    }\n}\n\n// SwiftUI View using same ViewModel\nstruct SwiftUIView: View {\n    @StateObject var viewModel = SharedViewModel()\n    \n    var body: some View {\n        VStack {\n            Text(viewModel.userData.name)\n            if viewModel.isLoading {\n                ProgressView()\n            }\n        }\n    }\n}"
            }
          }
        ]
      },
      {
        "id": "advanced-swiftui",
        "title": "Advanced SwiftUI",
        "slides": [
          {
            "type": "topic-title",
            "title": "Advanced SwiftUI Techniques"
          },
          {
            "type": "content",
            "emoji": "üé®",
            "title": "Custom Layout & Modifiers",
            "box": {
              "content": "<strong>Advanced SwiftUI Layout System</strong>",
              "code": "import SwiftUI\n\n// Custom ViewModifier\nstruct CardModifier: ViewModifier {\n    var backgroundColor: Color = .white\n    \n    func body(content: Content) -> some View {\n        content\n            .padding()\n            .background(backgroundColor)\n            .cornerRadius(12)\n            .shadow(color: .gray.opacity(0.4), radius: 4, x: 0, y: 2)\n    }\n}\n\n// Custom Layout\nstruct FlowLayout: Layout {\n    func sizeThatFits(proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) -> CGSize {\n        let sizes = subviews.map { $0.sizeThatFits(.unspecified) }\n        var currentPosition: CGPoint = .zero\n        var lineHeight: CGFloat = 0\n        var maxWidth: CGFloat = 0\n        \n        for size in sizes {\n            if currentPosition.x + size.width > (proposal.width ?? .infinity) {\n                currentPosition.x = 0\n                currentPosition.y += lineHeight + 8\n                lineHeight = 0\n            }\n            \n            currentPosition.x += size.width + 8\n            lineHeight = max(lineHeight, size.height)\n            maxWidth = max(maxWidth, currentPosition.x)\n        }\n        \n        return CGSize(width: maxWidth, height: currentPosition.y + lineHeight)\n    }\n    \n    func placeSubviews(in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) {\n        // Implementation for placing subviews\n    }\n}\n\n// Usage\nstruct ContentView: View {\n    var body: some View {\n        FlowLayout {\n            ForEach(0..<10, id: \\.self) { index in\n                Text(\"Item \\(index)\")\n                    .modifier(CardModifier(backgroundColor: .blue.opacity(0.1)))\n            }\n        }\n    }\n}"
            }
          },
          {
            "type": "content",
            "emoji": "üìê",
            "title": "Geometry Reader & Preferences",
            "box": {
              "content": "<strong>Advanced Layout Coordination</strong>",
              "code": "import SwiftUI\n\n// Geometry Reader for custom layouts\nstruct CustomCardView: View {\n    var body: some View {\n        GeometryReader { geometry in\n            VStack {\n                Text(\"Custom Layout\")\n                    .font(.title)\n                    .foregroundColor(.white)\n                \n                HStack {\n                    ForEach(0..<3) { index in\n                        Circle()\n                            .fill(Color.white.opacity(0.3))\n                            .frame(width: geometry.size.width / 6)\n                    }\n                }\n            }\n            .frame(width: geometry.size.width, height: geometry.size.height)\n            .background(\n                LinearGradient(\n                    colors: [.blue, .purple],\n                    startPoint: .topLeading,\n                    endPoint: .bottomTrailing\n                )\n            )\n        }\n        .frame(height: 200)\n    }\n}\n\n// Using PreferenceKey for view communication\nstruct SizePreferenceKey: PreferenceKey {\n    static var defaultValue: CGSize = .zero\n    static func reduce(value: inout CGSize, nextValue: () -> CGSize) {\n        value = nextValue()\n    }\n}\n\nstruct ViewSizeReader: View {\n    var body: some View {\n        GeometryReader { geometry in\n            Color.clear\n                .preference(key: SizePreferenceKey.self, value: geometry.size)\n        }\n    }\n}\n\nstruct ParentView: View {\n    @State private var childSize: CGSize = .zero\n    \n    var body: some View {\n        VStack {\n            Text(\"Child size: \\(Int(childSize.width)) x \\(Int(childSize.height))\")\n            \n            CustomCardView()\n                .background(ViewSizeReader())\n                .onPreferenceChange(SizePreferenceKey.self) { size in\n                    childSize = size\n                }\n        }\n    }\n}"
            }
          }
        ]
      },
      {
        "id": "uikit-advanced",
        "title": "UIKit Advanced",
        "slides": [
          {
            "type": "topic-title",
            "title": "Advanced UIKit Techniques"
          },
          {
            "type": "content",
            "emoji": "üèóÔ∏è",
            "title": "UIKit Fundamentals Refresher",
            "box": {
              "content": "<strong>UIViewController Lifecycle & AutoLayout</strong>",
              "code": "import UIKit\n\nclass AdvancedViewController: UIViewController {\n    \n    private let customView = CustomView()\n    private var loadingIndicator: UIActivityIndicatorView!\n    \n    // MARK: - Lifecycle\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupUI()\n        setupConstraints()\n    }\n    \n    override func viewWillAppear(_ animated: Bool) {\n        super.viewWillAppear(animated)\n        loadData()\n    }\n    \n    override func viewDidLayoutSubviews() {\n        super.viewDidLayoutSubviews()\n        updateCustomLayout()\n    }\n    \n    // MARK: - UI Setup\n    private func setupUI() {\n        view.backgroundColor = .systemBackground\n        \n        // Programmatic UI\n        loadingIndicator = UIActivityIndicatorView(style: .large)\n        loadingIndicator.translatesAutoresizingMaskIntoConstraints = false\n        view.addSubview(loadingIndicator)\n        \n        // Custom view\n        customView.translatesAutoresizingMaskIntoConstraints = false\n        view.addSubview(customView)\n    }\n    \n    // MARK: - AutoLayout Constraints\n    private func setupConstraints() {\n        NSLayoutConstraint.activate([\n            // Center loading indicator\n            loadingIndicator.centerXAnchor.constraint(equalTo: view.centerXAnchor),\n            loadingIndicator.centerYAnchor.constraint(equalTo: view.centerYAnchor),\n            \n            // Custom view constraints\n            customView.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 16),\n            customView.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -16),\n            customView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 20),\n            customView.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor, constant: -20)\n        ])\n    }\n    \n    private func updateCustomLayout() {\n        // Handle dynamic layout changes\n    }\n    \n    private func loadData() {\n        loadingIndicator.startAnimating()\n        // Async data loading\n    }\n}"
            }
          },
          {
            "type": "content",
            "emoji": "üé≠",
            "title": "Core Animation & Custom Transitions",
            "box": {
              "content": "<strong>Advanced UIKit Animations</strong>",
              "code": "import UIKit\n\nclass AnimatedViewController: UIViewController {\n    \n    private let animatedView = UIView()\n    private var animation: CAAnimation!\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupAnimatedView()\n        setupCoreAnimation()\n    }\n    \n    private func setupAnimatedView() {\n        animatedView.frame = CGRect(x: 50, y: 100, width: 100, height: 100)\n        animatedView.backgroundColor = .systemBlue\n        animatedView.layer.cornerRadius = 12\n        view.addSubview(animatedView)\n    }\n    \n    private func setupCoreAnimation() {\n        // CABasicAnimation\n        let positionAnimation = CABasicAnimation(keyPath: \"position.y\")\n        positionAnimation.fromValue = animatedView.layer.position.y\n        positionAnimation.toValue = animatedView.layer.position.y + 200\n        positionAnimation.duration = 2.0\n        positionAnimation.autoreverses = true\n        positionAnimation.repeatCount = .infinity\n        \n        // CAKeyframeAnimation\n        let bounceAnimation = CAKeyframeAnimation(keyPath: \"transform.scale\")\n        bounceAnimation.values = [1.0, 1.2, 0.8, 1.1, 1.0]\n        bounceAnimation.keyTimes = [0.0, 0.3, 0.6, 0.8, 1.0]\n        bounceAnimation.duration = 1.5\n        bounceAnimation.repeatCount = .infinity\n        \n        // CAAnimationGroup\n        let animationGroup = CAAnimationGroup()\n        animationGroup.animations = [positionAnimation, bounceAnimation]\n        animationGroup.duration = 2.0\n        animationGroup.repeatCount = .infinity\n        \n        animatedView.layer.add(animationGroup, forKey: \"groupAnimation\")\n    }\n}\n\n// Custom View Controller Transition\nclass CustomTransition: NSObject, UIViewControllerAnimatedTransitioning {\n    \n    func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -> TimeInterval {\n        return 0.6\n    }\n    \n    func animateTransition(using transitionContext: UIViewControllerContextTransitioning) {\n        guard let toVC = transitionContext.viewController(forKey: .to),\n              let fromVC = transitionContext.viewController(forKey: .from) else {\n            return\n        }\n        \n        let containerView = transitionContext.containerView\n        containerView.addSubview(toVC.view)\n        \n        toVC.view.alpha = 0.0\n        toVC.view.transform = CGAffineTransform(scaleX: 0.8, y: 0.8)\n        \n        UIView.animate(withDuration: transitionDuration(using: transitionContext), \n                       delay: 0, \n                       usingSpringWithDamping: 0.8, \n                       initialSpringVelocity: 0.5, \n                       options: []) {\n            toVC.view.alpha = 1.0\n            toVC.view.transform = .identity\n            fromVC.view.alpha = 0.0\n        } completion: { _ in\n            transitionContext.completeTransition(!transitionContext.transitionWasCancelled)\n        }\n    }\n}"
            }
          }
        ]
      },
      {
        "id": "combine-framework",
        "title": "Combine Framework",
        "slides": [
          {
            "type": "topic-title",
            "title": "Reactive Programming with Combine"
          },
          {
            "type": "content",
            "emoji": "‚ö°",
            "title": "Combine Fundamentals",
            "box": {
              "content": "<strong>Reactive Data Streams</strong>",
              "code": "import Combine\nimport SwiftUI\n\nclass UserViewModel: ObservableObject {\n    @Published var username: String = \"\"\n    @Published var password: String = \"\"\n    @Published var isValid: Bool = false\n    \n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        setupValidation()\n    }\n    \n    private func setupValidation() {\n        // Combine multiple publishers\n        Publishers.CombineLatest($username, $password)\n            .map { username, password in\n                // Form validation logic\n                return username.count >= 3 && password.count >= 6\n            }\n            .assign(to: \\.isValid, on: self)\n            .store(in: &cancellables)\n    }\n    \n    // Network request with Combine\n    func fetchUserData() -> AnyPublisher<User, Error> {\n        guard let url = URL(string: \"https://api.example.com/user\") else {\n            return Fail(error: URLError(.badURL))\n                .eraseToAnyPublisher()\n        }\n        \n        return URLSession.shared.dataTaskPublisher(for: url)\n            .map( \\.data )\n            .decode(type: User.self, decoder: JSONDecoder())\n            .receive(on: DispatchQueue.main)\n            .eraseToAnyPublisher()\n    }\n}\n\n// SwiftUI View using Combine\nstruct LoginView: View {\n    @StateObject private var viewModel = UserViewModel()\n    \n    var body: some View {\n        VStack {\n            TextField(\"Username\", text: $viewModel.username)\n                .textFieldStyle(RoundedBorderTextFieldStyle())\n            \n            SecureField(\"Password\", text: $viewModel.password)\n                .textFieldStyle(RoundedBorderTextFieldStyle())\n            \n            Button(\"Login\") {\n                // Handle login\n            }\n            .disabled(!viewModel.isValid)\n        }\n        .padding()\n    }\n}"
            }
          }
        ]
      },
      {
        "id": "navigation-state",
        "title": "Navigation & State",
        "slides": [
          {
            "type": "topic-title",
            "title": "Navigation & State Management"
          },
          {
            "type": "content",
            "emoji": "üß≠",
            "title": "Modern Navigation Patterns",
            "box": {
              "content": "<strong>SwiftUI Navigation & State Management</strong>",
              "code": "import SwiftUI\n\n// App State Management\nclass AppState: ObservableObject {\n    @Published var isLoggedIn: Bool = false\n    @Published var currentUser: User?\n    @Published var navigationPath = NavigationPath()\n}\n\n// Router for complex navigation\nclass Router: ObservableObject {\n    enum Route: Hashable {\n        case home\n        case profile(User)\n        case settings\n        case detail(Item)\n    }\n    \n    @Published var path = NavigationPath()\n    \n    func navigate(to route: Route) {\n        path.append(route)\n    }\n    \n    func popToRoot() {\n        path.removeLast(path.count)\n    }\n}\n\n// Main App Structure\nstruct ContentView: View {\n    @StateObject private var appState = AppState()\n    @StateObject private var router = Router()\n    \n    var body: some View {\n        NavigationStack(path: $router.path) {\n            Group {\n                if appState.isLoggedIn {\n                    MainTabView()\n                } else {\n                    LoginView()\n                }\n            }\n            .navigationDestination(for: Router.Route.self) { route in\n                switch route {\n                case .home:\n                    HomeView()\n                case .profile(let user):\n                    ProfileView(user: user)\n                case .settings:\n                    SettingsView()\n                case .detail(let item):\n                    DetailView(item: item)\n                }\n            }\n        }\n        .environmentObject(appState)\n        .environmentObject(router)\n    }\n}\n\n// ObservableObject for local state\nclass ProductViewModel: ObservableObject {\n    @Published var products: [Product] = []\n    @Published var isLoading: Bool = false\n    @Published var error: String?\n    \n    @MainActor\n    func loadProducts() async {\n        isLoading = true\n        defer { isLoading = false }\n        \n        do {\n            // Async/await network call\n            products = try await NetworkService.fetchProducts()\n        } catch {\n            self.error = error.localizedDescription\n        }\n    }\n}"
            }
          }
        ]
      },
      {
        "id": "animations",
        "title": "Animations",
        "slides": [
          {
            "type": "topic-title",
            "title": "Advanced Animations"
          },
          {
            "type": "content",
            "emoji": "üí´",
            "title": "SwiftUI Animations & Transitions",
            "box": {
              "content": "<strong>Implicit & Explicit Animations</strong>",
              "code": "import SwiftUI\n\nstruct AdvancedAnimationsView: View {\n    @State private var isAnimating = false\n    @State private var rotation: Double = 0\n    @Namespace private var animation\n    \n    var body: some View {\n        VStack(spacing: 30) {\n            // Implicit animation\n            Circle()\n                .fill(isAnimating ? .blue : .red)\n                .frame(width: isAnimating ? 100 : 50, height: isAnimating ? 100 : 50)\n                .animation(.easeInOut(duration: 1.0), value: isAnimating)\n            \n            // Explicit animation\n            Rectangle()\n                .fill(.green)\n                .frame(width: 100, height: 100)\n                .rotationEffect(.degrees(rotation))\n                .onTapGesture {\n                    withAnimation(.spring(response: 0.6, dampingFraction: 0.8)) {\n                        rotation += 360\n                    }\n                }\n            \n            // Matched geometry effect\n            HStack {\n                if !isAnimating {\n                    RoundedRectangle(cornerRadius: 10)\n                        .fill(.purple)\n                        .frame(width: 50, height: 50)\n                        .matchedGeometryEffect(id: \"shape\", in: animation)\n                }\n                \n                Spacer()\n                \n                if isAnimating {\n                    RoundedRectangle(cornerRadius: 25)\n                        .fill(.orange)\n                        .frame(width: 100, height: 100)\n                        .matchedGeometryEffect(id: \"shape\", in: animation)\n                }\n            }\n            \n            // Custom transition\n            if isAnimating {\n                Text(\"Hello SwiftUI!\")\n                    .font(.title)\n                    .transition(.asymmetric(\n                        insertion: .scale.combined(with: .opacity),\n                        removal: .move(edge: .trailing)\n                    ))\n            }\n            \n            Button(\"Animate\") {\n                withAnimation(.spring()) {\n                    isAnimating.toggle()\n                }\n            }\n        }\n        .padding()\n    }\n}\n\n// Custom Animatable Modifier\nstruct ShakeEffect: AnimatableModifier {\n    var shakes: CGFloat = 0\n    \n    var animatableData: CGFloat {\n        get { shakes }\n        set { shakes = newValue }\n    }\n    \n    func body(content: Content) -> some View {\n        content\n            .offset(x: sin(shakes * .pi * 2) * 10)\n    }\n}"
            }
          }
        ]
      },
      {
        "id": "data-persistence",
        "title": "Data Persistence",
        "slides": [
          {
            "type": "topic-title",
            "title": "Data Persistence & Core Data"
          },
          {
            "type": "content",
            "emoji": "üíæ",
            "title": "Core Data & SwiftData Integration",
            "box": {
              "content": "<strong>Modern Data Persistence</strong>",
              "code": "import SwiftUI\nimport CoreData\n\n// Core Data with SwiftUI\nclass PersistenceController {\n    static let shared = PersistenceController()\n    \n    let container: NSPersistentContainer\n    \n    init(inMemory: Bool = false) {\n        container = NSPersistentContainer(name: \"Model\")\n        \n        if inMemory {\n            container.persistentStoreDescriptions.first?.url = URL(fileURLWithPath: \"/dev/null\")\n        }\n        \n        container.loadPersistentStores { description, error in\n            if let error = error {\n                fatalError(\"Core Data store failed: \\(error.localizedDescription)\")\n            }\n        }\n    }\n}\n\nstruct ContentView: View {\n    @Environment(\\.managedObjectContext) private var viewContext\n    \n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\Item.timestamp, ascending: true)],\n        animation: .default)\n    private var items: FetchedResults<Item>\n    \n    var body: some View {\n        NavigationView {\n            List {\n                ForEach(items) { item in\n                    NavigationLink {\n                        Text(\"Item at \\(item.timestamp!, formatter: itemFormatter)\")\n                    } label: {\n                        Text(item.timestamp!, formatter: itemFormatter)\n                    }\n                }\n                .onDelete(perform: deleteItems)\n            }\n            .toolbar {\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    EditButton()\n                }\n                ToolbarItem {\n                    Button(action: addItem) {\n                        Label(\"Add Item\", systemImage: \"plus\")\n                    }\n                }\n            }\n        }\n    }\n    \n    private func addItem() {\n        withAnimation {\n            let newItem = Item(context: viewContext)\n            newItem.timestamp = Date()\n            \n            do {\n                try viewContext.save()\n            } catch {\n                let nsError = error as NSError\n                fatalError(\"Unresolved error \\(nsError), \\(nsError.userInfo)\")\n            }\n        }\n    }\n    \n    private func deleteItems(offsets: IndexSet) {\n        withAnimation {\n            offsets.map { items[$0] }.forEach(viewContext.delete)\n            \n            do {\n                try viewContext.save()\n            } catch {\n                let nsError = error as NSError\n                fatalError(\"Unresolved error \\(nsError), \\(nsError.userInfo)\")\n            }\n        }\n    }\n}\n\n// SwiftData (iOS 17+)\nimport SwiftData\n\n@Model\nclass SwiftDataItem {\n    var timestamp: Date\n    var title: String\n    \n    init(timestamp: Date, title: String) {\n        self.timestamp = timestamp\n        self.title = title\n    }\n}\n\nstruct SwiftDataView: View {\n    @Query(sort: \\SwiftDataItem.timestamp) private var items: [SwiftDataItem]\n    @Environment(\\.modelContext) private var modelContext\n    \n    var body: some View {\n        List(items) { item in\n            Text(item.title)\n        }\n    }\n}"
            }
          }
        ]
      },
      {
        "id": "networking",
        "title": "Networking",
        "slides": [
          {
            "type": "topic-title",
            "title": "Networking & Async Programming"
          },
          {
            "type": "content",
            "emoji": "üåê",
            "title": "Modern Networking with Async/Await",
            "box": {
              "content": "<strong>URLSession & Async/Await</strong>",
              "code": "import SwiftUI\n\n// Network Service with async/await\nclass NetworkService {\n    static let shared = NetworkService()\n    \n    private let session: URLSession\n    \n    init() {\n        let configuration = URLSessionConfiguration.default\n        configuration.timeoutIntervalForRequest = 30\n        configuration.timeoutIntervalForResource = 60\n        self.session = URLSession(configuration: configuration)\n    }\n    \n    // Generic network request\n    func request<T: Decodable>(_ endpoint: Endpoint) async throws -> T {\n        let request = try endpoint.urlRequest()\n        \n        let (data, response) = try await session.data(for: request)\n        \n        guard let httpResponse = response as? HTTPURLResponse,\n              (200...299).contains(httpResponse.statusCode) else {\n            throw NetworkError.invalidResponse\n        }\n        \n        do {\n            let decoder = JSONDecoder()\n            decoder.keyDecodingStrategy = .convertFromSnakeCase\n            return try decoder.decode(T.self, from: data)\n        } catch {\n            throw NetworkError.decodingError\n        }\n    }\n}\n\n// Endpoint protocol\nprotocol Endpoint {\n    var baseURL: String { get }\n    var path: String { get }\n    var method: HTTPMethod { get }\n    var headers: [String: String]? { get }\n    var parameters: [String: Any]? { get }\n}\n\nextension Endpoint {\n    func urlRequest() throws -> URLRequest {\n        guard let url = URL(string: baseURL + path) else {\n            throw NetworkError.invalidURL\n        }\n        \n        var request = URLRequest(url: url)\n        request.httpMethod = method.rawValue\n        request.allHTTPHeaderFields = headers\n        \n        if let parameters = parameters {\n            if method == .get {\n                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)\n                components?.queryItems = parameters.map { \n                    URLQueryItem(name: $0.key, value: \"\\($0.value)\")\n                }\n                request.url = components?.url\n            } else {\n                request.httpBody = try JSONSerialization.data(withJSONObject: parameters)\n            }\n        }\n        \n        return request\n    }\n}\n\n// Usage in ViewModel\nclass UserViewModel: ObservableObject {\n    @Published var users: [User] = []\n    @Published var isLoading = false\n    @Published var error: String?\n    \n    @MainActor\n    func fetchUsers() async {\n        isLoading = true\n        defer { isLoading = false }\n        \n        do {\n            let endpoint = UserEndpoint.getUsers\n            users = try await NetworkService.shared.request(endpoint)\n        } catch {\n            self.error = error.localizedDescription\n        }\n    }\n}\n\n// SwiftUI View\nstruct UserListView: View {\n    @StateObject private var viewModel = UserViewModel()\n    \n    var body: some View {\n        List(viewModel.users) { user in\n            Text(user.name)\n        }\n        .task {\n            await viewModel.fetchUsers()\n        }\n        .overlay {\n            if viewModel.isLoading {\n                ProgressView()\n            }\n        }\n    }\n}"
            }
          }
        ]
      },
      {
        "id": "multi-platform",
        "title": "Multi-Platform",
        "slides": [
          {
            "type": "topic-title",
            "title": "Multi-Platform Development"
          },
          {
            "type": "content",
            "emoji": "üì±",
            "title": "SwiftUI for iPadOS & watchOS",
            "box": {
              "content": "<strong>Adaptive Layouts & Platform-Specific Features</strong>",
              "code": "import SwiftUI\n\n// Multi-platform app structure\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n        \n        #if os(iOS)\n        // iPadOS specific scene\n        WindowGroup(for: Workflow.self) { $workflow in\n            WorkflowDetailView(workflow: workflow ?? .default)\n        }\n        .handlesExternalEvents(matching: [\"workflow\"])\n        #endif\n        \n        #if os(watchOS)\n        // watchOS specific scene\n        WKNotificationScene(controller: NotificationController.self, category: \"myCategory\")\n        #endif\n    }\n}\n\n// Adaptive View for multiple platforms\nstruct AdaptiveView: View {\n    @Environment(\\.horizontalSizeClass) private var horizontalSizeClass\n    @Environment(\\.verticalSizeClass) private var verticalSizeClass\n    \n    var body: some View {\n        Group {\n            if horizontalSizeClass == .compact && verticalSizeClass == .regular {\n                // iPhone portrait\n                CompactLayout()\n            } else if horizontalSizeClass == .regular && verticalSizeClass == .regular {\n                // iPad portrait\n                RegularLayout()\n            } else if horizontalSizeClass == .regular && verticalSizeClass == .compact {\n                // iPad landscape\n                WideLayout()\n            } else {\n                // Fallback\n                DefaultLayout()\n            }\n        }\n    }\n}\n\n// watchOS specific view\nstruct WatchAppView: View {\n    @State private var count = 0\n    \n    var body: some View {\n        VStack {\n            Text(\"Count: \\(count)\")\n                .font(.headline)\n            \n            Button(\"Increment\") {\n                count += 1\n            }\n            .buttonStyle(BorderedButtonStyle())\n        }\n        .navigationTitle(\"Watch App\")\n    }\n}\n\n// macOS specific modifications\nstruct MacOptimizedView: View {\n    var body: some View {\n        ContentView()\n            .frame(minWidth: 800, minHeight: 600)\n    }\n}\n\n// Platform-specific modifiers\nextension View {\n    func platformSpecificModifier() -> some View {\n        Group {\n            #if os(iOS)\n            self.background(Color(.systemBackground))\n            #elseif os(macOS)\n            self.background(Color(.windowBackgroundColor))\n            #elseif os(watchOS)\n            self.background(Color.black)\n            #endif\n        }\n    }\n}"
            }
          }
        ]
      },
      {
        "id": "performance",
        "title": "Performance",
        "slides": [
          {
            "type": "topic-title",
            "title": "Performance Optimization"
          },
          {
            "type": "content",
            "emoji": "‚ö°",
            "title": "Profiling & Optimization",
            "box": {
              "content": "<strong>Instruments & Performance Tools</strong>",
              "code": "import SwiftUI\n\n// Performance optimized views\nstruct OptimizedListView: View {\n    let items: [Item]\n    \n    var body: some View {\n        ScrollView {\n            LazyVStack {\n                ForEach(items) { item in\n                    OptimizedRow(item: item)\n                        .onAppear {\n                            // Preload data when row appears\n                            PreloadManager.shared.prefetch(for: item)\n                        }\n                }\n            }\n        }\n    }\n}\n\nstruct OptimizedRow: View {\n    let item: Item\n    \n    var body: some View {\n        HStack {\n            // Use EquatableView for expensive views\n            EquatableView(content: ExpensiveView(data: item.data))\n            \n            VStack(alignment: .leading) {\n                Text(item.title)\n                    .font(.headline)\n                Text(item.subtitle)\n                    .font(.subheadline)\n                    .foregroundColor(.secondary)\n            }\n            \n            Spacer()\n        }\n        .padding()\n        .background(Color(.systemBackground))\n        .cornerRadius(8)\n    }\n}\n\n// Equatable view for performance\nstruct ExpensiveView: View, Equatable {\n    let data: ExpensiveData\n    \n    var body: some View {\n        // Expensive rendering operations\n        Circle()\n            .fill(data.color)\n            .frame(width: 50, height: 50)\n            .overlay(\n                Text(\"\\(data.value)\")\n                    .foregroundColor(.white)\n            )\n    }\n    \n    static func == (lhs: ExpensiveView, rhs: ExpensiveView) -> Bool {\n        lhs.data.id == rhs.data.id && lhs.data.value == rhs.data.value\n    }\n}\n\n// Memory management\nclass ImageCache {\n    static let shared = ImageCache()\n    \n    private let cache = NSCache<NSString, UIImage>()\n    \n    func getImage(for key: String) -> UIImage? {\n        return cache.object(forKey: key as NSString)\n    }\n    \n    func setImage(_ image: UIImage, for key: String) {\n        cache.setObject(image, forKey: key as NSString)\n    }\n}\n\n// Background task optimization\nclass DataProcessor {\n    func processLargeDataset(_ data: [Data]) async {\n        await withTaskGroup(of: Void.self) { group in\n            for chunk in data.chunked(into: 100) {\n                group.addTask {\n                    await self.processChunk(chunk)\n                }\n            }\n        }\n    }\n    \n    private func processChunk(_ chunk: [Data]) async {\n        // Process data chunk\n        try? await Task.sleep(nanoseconds: 100_000_000) // Simulate work\n    }\n}"
            }
          }
        ]
      },
      {
        "id": "testing",
        "title": "Testing",
        "slides": [
          {
            "type": "topic-title",
            "title": "Testing & Debugging"
          },
          {
            "type": "content",
            "emoji": "üß™",
            "title": "XCTest & UI Testing",
            "box": {
              "content": "<strong>Comprehensive Testing Strategy</strong>",
              "code": "import XCTest\nimport SwiftUI\n@testable import MyApp\n\n// Unit Tests\nclass UserViewModelTests: XCTestCase {\n    var viewModel: UserViewModel!\n    var mockService: MockNetworkService!\n    \n    override func setUp() {\n        super.setUp()\n        mockService = MockNetworkService()\n        viewModel = UserViewModel(networkService: mockService)\n    }\n    \n    override func tearDown() {\n        viewModel = nil\n        mockService = nil\n        super.tearDown()\n    }\n    \n    func testUserValidation() async {\n        // Given\n        viewModel.username = \"test\"\n        viewModel.password = \"password\"\n        \n        // When\n        let isValid = viewModel.isValid\n        \n        // Then\n        XCTAssertTrue(isValid)\n    }\n    \n    func testUserFetchSuccess() async {\n        // Given\n        mockService.shouldSucceed = true\n        \n        // When\n        await viewModel.fetchUsers()\n        \n        // Then\n        XCTAssertFalse(viewModel.users.isEmpty)\n        XCTAssertFalse(viewModel.isLoading)\n        XCTAssertNil(viewModel.error)\n    }\n    \n    func testPerformance() {\n        measure {\n            // Performance test\n            for _ in 0..<1000 {\n                _ = viewModel.isValid\n            }\n        }\n    }\n}\n\n// UI Tests\nclass MyAppUITests: XCTestCase {\n    var app: XCUIApplication!\n    \n    override func setUp() {\n        super.setUp()\n        app = XCUIApplication()\n        app.launch()\n    }\n    \n    func testLoginFlow() {\n        // Given\n        let usernameField = app.textFields[\"username\"]\n        let passwordField = app.secureTextFields[\"password\"]\n        let loginButton = app.buttons[\"login\"]\n        \n        // When\n        usernameField.tap()\n        usernameField.typeText(\"testuser\")\n        \n        passwordField.tap()\n        passwordField.typeText(\"testpass\")\n        \n        loginButton.tap()\n        \n        // Then\n        let welcomeText = app.staticTexts[\"Welcome, testuser!\"]\n        XCTAssertTrue(welcomeText.waitForExistence(timeout: 5))\n    }\n}\n\n// Mock Services for Testing\nclass MockNetworkService: NetworkServiceProtocol {\n    var shouldSucceed = true\n    var mockUsers: [User] = [User(id: 1, name: \"Test User\")]\n    \n    func fetchUsers() async throws -> [User] {\n        if shouldSucceed {\n            return mockUsers\n        } else {\n            throw NetworkError.serverError\n        }\n    }\n}\n\n// SwiftUI Preview with test data\nstruct UserListView_Previews: PreviewProvider {\n    static var previews: some View {\n        UserListView()\n            .environmentObject(UserViewModel(networkService: MockNetworkService()))\n    }\n}"
            }
          }
        ]
      },
      {
        "id": "accessibility",
        "title": "Accessibility",
        "slides": [
          {
            "type": "topic-title",
            "title": "Accessibility & Localization"
          },
          {
            "type": "content",
            "emoji": "‚ôø",
            "title": "Inclusive Design",
            "box": {
              "content": "<strong>Accessibility & VoiceOver</strong>",
              "code": "import SwiftUI\n\nstruct AccessibleView: View {\n    @Environment(\\.sizeCategory) var sizeCategory\n    \n    var body: some View {\n        VStack {\n            // Accessibility labels\n            Image(\"profile\")\n                .resizable()\n                .aspectRatio(contentMode: .fit)\n                .accessibilityLabel(\"Profile picture of John Doe\")\n            \n            // Dynamic Type support\n            Text(\"Welcome to Our App\")\n                .font(.system(size: 24, weight: .bold, design: .rounded))\n                .minimumScaleFactor(0.5)\n                .lineLimit(2)\n            \n            // Accessible controls\n            Button(\"Continue\") {\n                // Action\n            }\n            .accessibilityHint(\"Double tap to proceed to the next screen\")\n            .accessibilityAddTraits(.isButton)\n            \n            // VoiceOver support\n            VStack(alignment: .leading) {\n                Text(\"Total Amount\")\n                    .accessibilityHidden(true) // Hide from VoiceOver\n                \n                Text(\"$99.99\")\n                    .font(.title)\n                    .accessibilityLabel(\"Total amount ninety nine dollars and ninety nine cents\")\n            }\n            \n            // Accessibility actions\n            HStack {\n                Text(\"Swipe for options\")\n                    .accessibilityAction(named: \"Edit\") {\n                        // Edit action\n                    }\n                    .accessibilityAction(named: \"Delete\") {\n                        // Delete action\n                    }\n            }\n            \n            // Support for different size categories\n            if sizeCategory >= .accessibilityLarge {\n                ScrollView {\n                    content\n                }\n            } else {\n                content\n            }\n        }\n        .accessibilityElement(children: .combine)\n    }\n    \n    private var content: some View {\n        VStack {\n            // Regular content\n        }\n    }\n}\n\n// Localization\nstruct LocalizedView: View {\n    var body: some View {\n        VStack {\n            Text(\"welcome_message\", bundle: .main)\n            Text(\"number_of_items\", bundle: .main, \n                 arguments: [5])\n            \n            // Formatted dates and numbers\n            Text(Date(), style: .date)\n            Text(99.99, format: .currency(code: \"USD\"))\n        }\n    }\n}\n\n// Right-to-left support\nstruct RTLSupportView: View {\n    @Environment(\\.layoutDirection) var layoutDirection\n    \n    var body: some View {\n        HStack {\n            Text(\"Leading\")\n            Spacer()\n            Text(\"Trailing\")\n        }\n        .flipsForRightToLeftLayoutDirection(true)\n    }\n}"
            }
          }
        ]
      },
      {
        "id": "architecture",
        "title": "Architecture",
        "slides": [
          {
            "type": "topic-title",
            "title": "App Architecture"
          },
          {
            "type": "content",
            "emoji": "üèõÔ∏è",
            "title": "Design Patterns & Architecture",
            "box": {
              "content": "<strong>MVVM, TCA & Clean Architecture</strong>",
              "code": "import SwiftUI\nimport Combine\n\n// MVVM with SwiftUI\nclass LoginViewModel: ObservableObject {\n    @Published var email: String = \"\"\n    @Published var password: String = \"\"\n    @Published var isLoading: Bool = false\n    @Published var error: String?\n    \n    private let authService: AuthServiceProtocol\n    private var cancellables = Set<AnyCancellable>()\n    \n    init(authService: AuthServiceProtocol = AuthService()) {\n        self.authService = authService\n    }\n    \n    @MainActor\n    func login() async {\n        isLoading = true\n        defer { isLoading = false }\n        \n        do {\n            try await authService.login(email: email, password: password)\n            // Navigate to home\n        } catch {\n            self.error = error.localizedDescription\n        }\n    }\n    \n    var isValid: Bool {\n        !email.isEmpty && email.contains(\"@\") && password.count >= 6\n    }\n}\n\nstruct LoginView: View {\n    @StateObject private var viewModel = LoginViewModel()\n    \n    var body: some View {\n        VStack {\n            TextField(\"Email\", text: $viewModel.email)\n                .textContentType(.emailAddress)\n                .keyboardType(.emailAddress)\n            \n            SecureField(\"Password\", text: $viewModel.password)\n                .textContentType(.password)\n            \n            if let error = viewModel.error {\n                Text(error)\n                    .foregroundColor(.red)\n            }\n            \n            Button(\"Login\") {\n                Task {\n                    await viewModel.login()\n                }\n            }\n            .disabled(!viewModel.isValid || viewModel.isLoading)\n            \n            if viewModel.isLoading {\n                ProgressView()\n            }\n        }\n        .padding()\n    }\n}\n\n// The Composable Architecture (TCA) example\nimport ComposableArchitecture\n\nstruct AppState: Equatable {\n    var count = 0\n    var isLoading = false\n}\n\nenum AppAction: Equatable {\n    case increment\n    case decrement\n    case reset\n    case setLoading(Bool)\n}\n\nstruct AppEnvironment {\n    var mainQueue: AnySchedulerOf<DispatchQueue>\n}\n\nlet appReducer = Reducer<AppState, AppAction, AppEnvironment> { state, action, environment in\n    switch action {\n    case .increment:\n        state.count += 1\n        return .none\n        \n    case .decrement:\n        state.count -= 1\n        return .none\n        \n    case .reset:\n        state.count = 0\n        return .none\n        \n    case .setLoading(let isLoading):\n        state.isLoading = isLoading\n        return .none\n    }\n}\n\nstruct TCAView: View {\n    let store: Store<AppState, AppAction>\n    \n    var body: some View {\n        WithViewStore(self.store) { viewStore in\n            VStack {\n                Text(\"\\(viewStore.count)\")\n                    .font(.title)\n                \n                HStack {\n                    Button(\"-\") { viewStore.send(.decrement) }\n                    Button(\"Reset\") { viewStore.send(.reset) }\n                    Button(\"+\") { viewStore.send(.increment) }\n                }\n            }\n        }\n    }\n}"
            }
          }
        ]
      },
      {
        "id": "deployment",
        "title": "Deployment",
        "slides": [
          {
            "type": "topic-title",
            "title": "Deployment & CI/CD"
          },
          {
            "type": "content",
            "emoji": "üöÄ",
            "title": "App Store & Continuous Integration",
            "box": {
              "content": "<strong>Deployment Pipeline</strong>",
              "code": "#!/bin/bash\n\n# Fastlane setup for automation\n# fastlane/Fastfile\n\ndefault_platform(:ios)\n\nplatform :ios do\n  desc \"Submit a new beta build to TestFlight\"\n  lane :beta do\n    increment_build_number\n    build_app(scheme: \"MyApp\")\n    upload_to_testflight\n  end\n\n  desc \"Deploy a new version to the App Store\"\n  lane :release do\n    beta\n    appstore(\n      api_key: app_store_connect_api_key,\n      submit_for_review: true\n    )\n  end\n\n  desc \"Run tests\"\n  lane :test do\n    run_tests(scheme: \"MyApp\")\n  end\nend\n\n# GitHub Actions CI/CD\n# .github/workflows/ios.yml\n\nname: iOS CI\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  build-and-test:\n    runs-on: macos-latest\n    \n    steps:\n    - uses: actions/checkout@v3\n    \n    - name: Select Xcode\n      run: sudo xcode-select -switch /Applications/Xcode_15.0.app\n      \n    - name: Install dependencies\n      run: |\n        brew install cocoapods\n        pod install\n        \n    - name: Build\n      run: |\n        xcodebuild clean build \\\n          -workspace MyApp.xcworkspace \\\n          -scheme MyApp \\\n          -destination 'platform=iOS Simulator,name=iPhone 14,OS=latest'\n          \n    - name: Run tests\n      run: |\n        xcodebuild test \\\n          -workspace MyApp.xcworkspace \\\n          -scheme MyApp \\\n          -destination 'platform=iOS Simulator,name=iPhone 14,OS=latest'\n\n# Xcode Cloud configuration\n# .xcodecloud/workflows/ci.yml\n\nversion: 1\n\nworkflows:\n  myapp-ci:\n    name: MyApp CI\n    actions:\n      - name: Build and Test\n        type: test\n        scheme: MyApp\n        destination:\n          platform: iOS Simulator\n          name: iPhone 14\n    \n    triggers:\n      - name: Build on Pull Request\n        type: pull-request\n        branches:\n          - main\n        actions:\n          - Build and Test"
            }
          }
        ]
      },
      {
        "id": "case-study",
        "title": "Case Study",
        "slides": [
          {
            "type": "topic-title",
            "title": "Real-World Integration"
          },
          {
            "type": "content",
            "emoji": "üì±",
            "title": "Hybrid App Case Study",
            "box": {
              "content": "<strong>Complete Hybrid App Example</strong>",
              "code": "import SwiftUI\nimport UIKit\nimport Combine\n\n// Main App Coordinator\nclass AppCoordinator: ObservableObject {\n    @Published var currentView: AppView = .splash\n    \n    enum AppView {\n        case splash\n        case login\n        case main\n        case settings\n    }\n    \n    func navigate(to view: AppView) {\n        withAnimation {\n            currentView = view\n        }\n    }\n}\n\n// Hybrid App Main View\nstruct HybridAppView: View {\n    @StateObject private var coordinator = AppCoordinator()\n    @StateObject private var userSession = UserSession()\n    \n    var body: some View {\n        Group {\n            switch coordinator.currentView {\n            case .splash:\n                SplashView()\n                    .onAppear {\n                        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {\n                            coordinator.navigate(to: userSession.isLoggedIn ? .main : .login)\n                        }\n                    }\n                    \n            case .login:\n                LoginView()\n                    .environmentObject(coordinator)\n                    \n            case .main:\n                MainTabView()\n                    .environmentObject(coordinator)\n                    \n            case .settings:\n                SettingsView()\n                    .environmentObject(coordinator)\n            }\n        }\n        .environmentObject(userSession)\n    }\n}\n\n// UIKit Integration in SwiftUI\nstruct LegacySettingsView: UIViewControllerRepresentable {\n    @EnvironmentObject var coordinator: AppCoordinator\n    \n    func makeUIViewController(context: Context) -> LegacySettingsViewController {\n        let controller = LegacySettingsViewController()\n        controller.delegate = context.coordinator\n        return controller\n    }\n    \n    func updateUIViewController(_ uiViewController: LegacySettingsViewController, context: Context) {\n        // Update the UIKit view controller if needed\n    }\n    \n    func makeCoordinator() -> Coordinator {\n        Coordinator(self)\n    }\n    \n    class Coordinator: NSObject, LegacySettingsDelegate {\n        let parent: LegacySettingsView\n        \n        init(_ parent: LegacySettingsView) {\n            self.parent = parent\n        }\n        \n        func didUpdateSettings() {\n            // Handle settings update\n        }\n        \n        func didRequestNavigation() {\n            parent.coordinator.navigate(to: .main)\n        }\n    }\n}\n\n// Legacy UIKit View Controller\nprotocol LegacySettingsDelegate: AnyObject {\n    func didUpdateSettings()\n    func didRequestNavigation()\n}\n\nclass LegacySettingsViewController: UIViewController {\n    weak var delegate: LegacySettingsDelegate?\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupUI()\n    }\n    \n    private func setupUI() {\n        view.backgroundColor = .systemBackground\n        \n        let button = UIButton(type: .system)\n        button.setTitle(\"Save Settings\", for: .normal)\n        button.addTarget(self, action: #selector(saveTapped), for: .touchUpInside)\n        \n        view.addSubview(button)\n        button.translatesAutoresizingMaskIntoConstraints = false\n        NSLayoutConstraint.activate([\n            button.centerXAnchor.constraint(equalTo: view.centerXAnchor),\n            button.centerYAnchor.constraint(equalTo: view.centerYAnchor)\n        ])\n    }\n    \n    @objc private func saveTapped() {\n        delegate?.didUpdateSettings()\n        delegate?.didRequestNavigation()\n    }\n}"
            }
          }
        ]
      },
      {
        "id": "future",
        "title": "Future",
        "slides": [
          {
            "type": "topic-title",
            "title": "Future of iOS Development"
          },
          {
            "type": "content",
            "emoji": "üîÆ",
            "title": "Apple's Direction & Future-Proofing",
            "box": {
              "list": [
                {
                  "emoji": "üöÄ",
                  "text": "<strong>SwiftUI Maturation</strong> - More components, better performance"
                },
                {
                  "emoji": "ü§ñ",
                  "text": "<strong>AI Integration</strong> - Core ML, on-device intelligence"
                },
                {
                  "emoji": "üåê",
                  "text": "<strong>Cross-Platform</strong> - visionOS, macOS, watchOS convergence"
                },
                {
                  "emoji": "‚ö°",
                  "text": "<strong>Performance</strong> - Metal, Swift Concurrency advances"
                },
                {
                  "emoji": "üîí",
                  "text": "<strong>Privacy</strong> - Enhanced user privacy features"
                },
                {
                  "emoji": "üéØ",
                  "text": "<strong>AR/VR</strong> - visionOS and spatial computing"
                }
              ]
            }
          }
        ]
      },
      {
        "id": "cheat-sheet",
        "title": "Cheat Sheet",
        "slides": [
          {
            "type": "content",
            "emoji": "üìã",
            "title": "iOS Development Quick Reference",
            "box": {
              "content": "<strong>Essential Patterns & APIs</strong>",
              "code": "// SwiftUI Basics\n@State, @Binding, @StateObject, @ObservedObject, @EnvironmentObject\n\n// UIKit Integration\nUIHostingController, UIViewControllerRepresentable, UIViewRepresentable\n\n// Navigation\nNavigationStack, NavigationPath, navigationDestination\n\n// Data Flow\nCombine, async/await, @Published, ObservableObject\n\n// Architecture\nMVVM, MVC, TCA, Coordinator Pattern\n\n// Performance\nLazyVStack, EquatableView, @ViewBuilder, Task\n\n// Testing\nXCTest, @testable, XCUIApplication, setUp/tearDown\n\n// Deployment\nFastlane, TestFlight, App Store Connect, CI/CD\n\n// Key Frameworks\nSwiftUI, UIKit, Combine, Core Data, Core Animation, URLSession"
            }
          }
        ]
      },
      {
        "id": "resources",
        "title": "Resources",
        "slides": [
          {
            "type": "content",
            "emoji": "üìö",
            "title": "Continue Learning iOS",
            "box": {
              "list": [
                {
                  "emoji": "üåê",
                  "text": "<strong>Apple Developer Documentation</strong> - Official docs"
                },
                {
                  "emoji": "üìñ",
                  "text": "<strong>SwiftUI by Example</strong> - Practical guide"
                },
                {
                  "emoji": "üéì",
                  "text": "<strong>WWDC Videos</strong> - Annual conference sessions"
                },
                {
                  "emoji": "üíª",
                  "text": "<strong>Ray Wenderlich</strong> - Tutorials and courses"
                },
                {
                  "emoji": "üé•",
                  "text": "<strong>Swiftful Thinking</strong> - YouTube channel"
                },
                {
                  "emoji": "üîß",
                  "text": "<strong>SwiftUI Lab</strong> - Advanced techniques"
                }
              ]
            }
          }
        ]
      },
      {
        "id": "hands-on-project",
        "title": "Hands-On Project",
        "slides": [
          {
            "type": "content",
            "emoji": "üî®",
            "title": "Mini Project: Social Media App",
            "box": {
              "list": [
                {
                  "emoji": "1Ô∏è‚É£",
                  "text": "Setup hybrid SwiftUI/UIKit project structure"
                },
                {
                  "emoji": "2Ô∏è‚É£",
                  "text": "Implement authentication with Combine"
                },
                {
                  "emoji": "3Ô∏è‚É£",
                  "text": "Build feed with SwiftUI + UIKit cells"
                },
                {
                  "emoji": "4Ô∏è‚É£",
                  "text": "Add real-time messaging with WebSockets"
                },
                {
                  "emoji": "5Ô∏è‚É£",
                  "text": "Implement Core Data for offline support"
                },
                {
                  "emoji": "6Ô∏è‚É£",
                  "text": "Add advanced animations and transitions"
                },
                {
                  "emoji": "7Ô∏è‚É£",
                  "text": "Implement comprehensive testing"
                },
                {
                  "emoji": "8Ô∏è‚É£",
                  "text": "Setup CI/CD with Fastlane"
                }
              ]
            }
          }
        ]
      },
      {
        "id": "quiz",
        "title": "Quick Quiz",
        "slides": [
          {
            "type": "content",
            "emoji": "üß†",
            "title": "Test Your iOS Knowledge",
            "box": {
              "list": [
                {
                  "emoji": "1Ô∏è‚É£",
                  "text": "When should you use UIViewControllerRepresentable?"
                },
                {
                  "emoji": "2Ô∏è‚É£",
                  "text": "What's the difference between @State and @StateObject?"
                },
                {
                  "emoji": "3Ô∏è‚É£",
                  "text": "How do you optimize SwiftUI list performance?"
                },
                {
                  "emoji": "4Ô∏è‚É£",
                  "text": "What are the benefits of using Combine with SwiftUI?"
                },
                {
                  "emoji": "5Ô∏è‚É£",
                  "text": "How do you handle navigation in a hybrid app?"
                }
              ]
            }
          }
        ]
      },
      {
        "id": "recap",
        "title": "Quick Recap",
        "slides": [
          {
            "type": "content",
            "emoji": "üìù",
            "title": "Key Takeaways",
            "box": {
              "list": [
                {
                  "emoji": "üîó",
                  "text": "Hybrid approach = SwiftUI + UIKit + Combine"
                },
                {
                  "emoji": "üéØ",
                  "text": "Use SwiftUI for new features, UIKit for complex custom UI"
                },
                {
                  "emoji": "‚ö°",
                  "text": "Combine enables reactive data flow"
                },
                {
                  "emoji": "üèóÔ∏è",
                  "text": "Proper architecture is crucial for maintainability"
                },
                {
                  "emoji": "üß™",
                  "text": "Comprehensive testing ensures app quality"
                },
                {
                  "emoji": "üöÄ",
                  "text": "Performance optimization is key for user experience"
                }
              ]
            }
          }
        ]
      },
      {
        "id": "qa-and-thank-you",
        "title": "Q&A and Thank You",
        "slides": [
          {
            "type": "qa",
            "title": "Questions? üí¨",
            "content": "Let's discuss iOS development, SwiftUI, UIKit, or specific challenges!<br><span class=\"gradient-accent\">All iOS questions welcome!</span>"
          },
          {
            "type": "thank-you",
            "title": "Thank You! üéâ",
            "box": {
              "content": "<span class=\"emoji\">üì±</span> Ready to build amazing iOS apps?<br><span class=\"gradient-accent\">Start your advanced iOS journey today!</span>",
              "note": "Modern ‚Ä¢ Powerful ‚Ä¢ Professional"
            },
            "footer": {
              "org": "Bude Global Enterprise - India",
              "tagline": "Empowering mobile developers worldwide"
            }
          }
        ]
      }
    ]
  }
}